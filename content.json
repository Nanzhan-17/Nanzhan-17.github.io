{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/08/hello-world/"},{"title":"Windows10 和 VSCode 上Haskell的安装与环境搭建","text":"在Windows10 和 VSCode 上安装搭建Haskell环境 参考资料：【VS Code】Windows10下VS Code配置Haskell语言环境在整体的环境安装配置过程中，多处涉及到github链接和需要翻墙的链接，部分校园网可能会链接失败，可以尝试手机热点。 1. 下载安装Stack打开Stack官方文档，选择Windows 64-bit Installer进行下载，双击下载下来的exe文件进行安装，可以自定义C盘路径，但是要以管理员身份运行。 Windows 64-bit Installer 安装步骤1 安装过程中，还会自动将Stack添加到用户环境变量 PATH 中，同时会设置 STACK_ROOT=C:\\sr（安装程序的默认选项，记住这个路径，后面要考），安装完成后，可以在cmd终端输入命令“stack –help”来检验安装是否成功。 安装步骤2 2. 安装GHC（麻烦bug多）Stack可以用于管理Haskell编译器GHC和Haskell库，因此使用Stack安装GHC。 由于Haskell的生态和版本支持不是很好，如果你直接安装而不固定版本号，软件包的安装就容易引起冲突，导致各种依赖项间的不兼容。访问这个网站，查看Haskell最新的LTS，然后锁定在这个LTS上，此处我选择的是最新的LTS 18.27。 Stackage 一些辅助理解的概念（和配置环境关系不大，你可以不看）： Hackage是Haskell社区的开源软件包仓库 The Haskell Package Repository ，可以发布库和程序，或者使用Cabal-install这样的软件包管理器下载和安装软件包。 Stackage是 Stable Haskell package sets 的缩写，即稳定一致的Haskell包集合。它是一个Haskell软件包子集的发行版，来自Hackage并和它一同被社区构建起来。Stackage存在的意义在于，它提供了兼容一致且稳定的Haskell包集，每个包都选择了一个特定版本以满足软件包集合的自洽性，从而解决包版本的冲突问题、顺利构建和运行项目。 Stackage提供和维护了一堆不同的大版本，每个大版本都对应一个兼容一致稳定的Haskell包集，或者说是一个LTS Long Term Service ，被社区长期支持。我们选定了一个LTS之后，在下载安装时只可能发生某个包不存在的情况，就算出现冲突也能通过Stack来轻松解决，不会埋下一大堆“地雷”。 2.1 配置stack在cmd终端执行stack install，会发现下载经常失败。 1(ConnectionFailure user error (Network.Socket.gai_strerror not supported: 11004)) 这是因为下载过程中的一个网址需要翻墙才能访问，在不翻墙的情况下，需要进行换源才可以下载成功。 参考资料：关于stack换源的问题 其中提到了两个清华源的网址，“可以同时使用 TUNA 的 Stackage 源 + Hackage 源来解决”，分别是stackage 镜像使用帮助和hackage 镜像使用帮助。 在stackage 镜像使用帮助中提到“本镜像推荐与 TUNA 的 Hackage 镜像配合使用”，因此两个镜像源都需要添加。 2.2 换源：在终端输入stack --version查看stack版本，然后在上述两个源链接中分别找到对应版本的源进行更换，我的stack版本是2.7.3，在这里说明我的换源过程： （1）下载 stackage 镜像中提示的文件： stackage 镜像 下载图片下方蓝色链接的global-hints.yaml文件，在系统中找到对应的文件夹，不同下载路径对应的文件夹不同，此处的路径就是上文提及的记下来要考的路径： 默认路径下载时，直接在c盘路径输入%APPDATA%，然后回车就可以打开对应文件夹。 %APPDATA% 我下载的时候更改了默认路径，所以要修改的配置文件是%STACK_ROOT%\\config.yaml，配置文件对应的路径是上面记住要考的哪个C:\\sr\\config.yaml。 （2）更换源现在你已经找到了对应的目录，在此目录下的pantry文件夹内放入刚刚下载好的global-hints.yaml文件，并更改 stack（默认路径）或sr（我更改的路径）目录下的config.yaml，在此文件中增添两个镜像源中对应版本的代码，我的版本是2.7.3： stack hackage 即在config.yaml中增加以下代码： 123456789101112131415161718192021222324package-indices: - download-prefix: http://mirrors.tuna.tsinghua.edu.cn/hackage/ hackage-security: keyids: - 0a5c7ea47cd1b15f01f5f51a33adda7e655bc0f0b0615baa8e271f4c3351e21d - 1ea9ba32c526d1cc91ab5e5bd364ec5e9e8cb67179a471872f6e26f0ae773d42 - 280b10153a522681163658cb49f632cde3f38d768b736ddbc901d99a1a772833 - 2a96b1889dc221c17296fcc2bb34b908ca9734376f0f361660200935916ef201 - 2c6c3627bd6c982990239487f1abd02e08a02e6cf16edb105a8012d444d870c3 - 51f0161b906011b52c6613376b1ae937670da69322113a246a09f807c62f6921 - 772e9f4c7db33d251d5c6e357199c819e569d130857dc225549b40845ff0890d - aa315286e6ad281ad61182235533c41e806e5a787e0b6d1e7eef3f09d137d2e9 - fe331502606802feac15e514d9b9ea83fee8b6ffef71335479a2e68d84adc6b0 key-threshold: 3 # number of keys required # ignore expiration date, see https://github.com/commercialhaskell/stack/pull/4614 ignore-expiry: nosetup-info-locations: [&quot;http://mirrors.tuna.tsinghua.edu.cn/stackage/stack-setup.yaml&quot;]urls: latest-snapshot: http://mirrors.tuna.tsinghua.edu.cn/stackage/snapshots.jsonsnapshot-location-base: https://mirrors.tuna.tsinghua.edu.cn/stackage/stackage-snapshots/ （3）配置GHC回到终端，运行命令stack --resolver lts-18.27 setup下载lts，成功代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253C:\\Users\\hp&gt;stack --resolver lts-18.27 setupWarning: http://mirrors.tuna.tsinghua.edu.cn/stackage/stack-setup.yaml: Unrecognized field in GHCDownloadInfo: versionPreparing to install GHC to an isolated location.This will not interfere with any system-level installation.Already downloaded.Downloaded 7z.dll.Downloaded 7z.exe.Decompressing ghc-8.10.7.tar.xz...7-Zip 9.20 Copyright (c) 1999-2010 Igor Pavlov 2010-11-18Processing archive: C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.10.7.tar.xzExtracting ghc-8.10.7.tarEverything is OkSize: 2768711680Compressed: 434126144Extracting ghc-8.10.7.tar...Extracted total of 10342 files from ghc-8.10.7.tarGHC installed to C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.10.7\\Downloaded msys2-20210604.Already downloaded.Already downloaded.Decompressing msys2-20210604.tar.xz...7-Zip 9.20 Copyright (c) 1999-2010 Igor Pavlov 2010-11-18Processing archive: C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\msys2-20210604.tar.xzExtracting msys2-20210604.tarEverything is OkSize: 390021120Compressed: 99822772Extracting msys2-20210604.tar...Extracted total of 17688 files from msys2-20210604.tarCopying skeleton files.These files are for the users to personalise their msys2 experience.They will never be overwritten nor automatically updated.'./.bashrc' -&gt; '/home/hp/.bashrc''./.bash_logout' -&gt; '/home/hp/.bash_logout''./.bash_profile' -&gt; '/home/hp/.bash_profile''./.inputrc' -&gt; '/home/hp/.inputrc''./.profile' -&gt; '/home/hp/.profile'\u001b[0mstack will use a sandboxed GHC it installed\u001b[0m\u001b[0mFor more information on paths, see 'stack path' and 'stack exec env'\u001b[0m\u001b[0mTo use this GHC and packages outside of a project, consider using:\u001b[0m\u001b[0mstack ghc, stack ghci, stack runghc, or stack exec\u001b[0m 测试一下GHC是否安装成功： 1234567C:\\Users\\hp&gt;stack exec -- ghc --versionThe Glorious Glasgow Haskell Compilation System, version 8.10.7C:\\Users\\hp&gt;stack exec -- ghciGHCi, version 8.10.7: https://www.haskell.org/ghc/ :? for helpPrelude&gt; :quitLeaving GHCi. 到此，我们已经有了一个可用的Stack和GHC（芜湖撒花）。 3.配置VSCode3.1 安装插件由于VSCode中的一部分插件版本过老，和新版本的GHC不匹配，因此下载旧版本的GHC做备用，一般来说LTS9不会出现冲突。 在终端执行以下命令进行安装，并检测安装是否成功： 12stack --resolver lts-9.21 setupstack --compiler ghc-8.0.2 exec -- ghc --version 配置完成后，在VSCode扩展中安装以下插件： Haskell ghc-mod Haskell-linter Haskell Syntax Highlighting Haskelly Haskell Code Runner 然后在终端配置插件，分别执行以下命令（这一步所需时间较长，如果一次没配置完，第二次重新打开终端时，需要重新输入chcp 65001） 1234chcp 65001stack --resolver lts-9.21 install ghc-modstack --resolver lts-9.21 install hlintstack --resolver lts-9.21 install intero QuickCheck stack-run 以上这些安装完成后，终端显示如下，不用管那个Warning，但是要记住他那个路径 C:\\Users\\hp\\AppData\\Roaming\\local\\bin，Stack安装的所有扩展应该都在这个路径中，这个路径在配置settings.json时需要用到。 安装完成 3.2 配置Haskell语言学习环境（1）配置ghc-mod、hlint、Code Runner在VSCode中打开 文件（File）- 首项选（Preferences）- 设置（Settings），点击下图红圈的位置，打开settings.json。 设置 settings.json 在settings.json文件中加入以下代码，注意在第8行末尾增加逗号，其中Haskell-linter配置的路径就是上面那个提示的路径。 12345678 /* Haskell ghc-mod配置 */ &quot;haskell.ghcMod.executablePath&quot;: &quot;stack&quot;, /* Haskell-linter配置 */ &quot;haskell.hlint.executablePath&quot;: &quot;C:\\\\Users\\\\hp\\\\AppData\\\\Roaming\\\\local\\\\bin\\\\hlint.exe&quot;, /* code-runner配置 */ &quot;code-runner.executorMap&quot;: { &quot;haskell&quot;: &quot;cd $dir &amp;&amp; stack runhaskell $fileName&quot;}, settings-over ** 2）配置Haskell**由于使用的是Stack，下列配置项要么添加到全局配置文件 $STACK_ROOT\\config.yaml 中，要么添加到项目配置文件 stack.yaml 中： 12ghc-options: '$everything': -haddock # 一个从带注释的Haskell源代码自动生成文档的工具 4. 尝试使用经过以上操作，haskell的环境基本搭建完毕，写一个简单的Hello World来测试是否成功。在VSCode运行.hs文件基本有以下三种方式： 在终端输入stack runhaskell &quot;.hs文件路径&quot;（最稳定）。 点击右上角的小三角运行按钮。 点击最下面蓝色行用红笔圈出的Run File运行文件。 可以看到成功输出了Hello World。 爷终于成功了哈哈哈哈哈 tips:在实际使用的过程中，想引用import System.Random时却发现系统提示没有这个模块，在查找了无数资料后，终于在这个网站中找到了可行的解决方案，可以尝试在终端输入下面的第一行代码，如果无效则尝试第二行代码： 12stack install randomstack ghci --package random 附：一些个人认为比较有用的Haskell入门资料 Haskell - 条件判断 Haskell系列（三）列表","link":"/2022/03/10/Windows10-%E5%92%8C-VSCode-%E4%B8%8AHaskell%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"计算机网络实验 Labexercise1-1 Protocol Layers","text":"前言：本博客包含Windows10下安装wget、Wireshark。 一些有用的链接： Labexercise1-1 Protocol Layers翻译 wireshark练习及答案lab-protocol-layers.docx Wireshark抓包使用指南 山东大学计算机网络实验 一些有用的提示：开始实验进行抓包时，校园网环境下的同学不建议使用一些 [ 上网不涉密涉密不上网 ] 的校园网进行抓包，可能会导致抓不到包捏 :)（找了半天bug，气死我了） 1. 下载安装wget参考资料：wget for windows 下载与安装 点击此链接，选择合适的版本下载.exe文件，然后把下好的.exe文件放在C:/windows/system32目录下即可。 在cmd终端输入wget --version，显示如下，则安装成功: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849C:\\Users\\hp\\Desktop&gt;wget --versionGNU Wget 1.21.2 built on mingw32.+cares +digest +gpgme +https +ipv6 +iri +large-file +metalink -nls+ntlm +opie +psl +ssl/opensslWgetrc: /win32dev/misc/wget/out64/etc/wgetrc (system)Compile: x86_64-w64-mingw32-gcc -DHAVE_CONFIG_H -DSYSTEM_WGETRC=&quot;/win32dev/misc/wget/out64/etc/wgetrc&quot; -DLOCALEDIR=&quot;/win32dev/misc/wget/out64/share/locale&quot; -I. -I../../src -I../lib -I../../lib -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DCARES_STATICLIB -I/win32dev/misc/wget/out64/include -DPCRE2_STATIC -I/win32dev/misc/wget/out64/include -DHAVE_LIBSSL -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DNDEBUG -ggdbLink: x86_64-w64-mingw32-gcc -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DCARES_STATICLIB -I/win32dev/misc/wget/out64/include -DPCRE2_STATIC -I/win32dev/misc/wget/out64/include -DHAVE_LIBSSL -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DNDEBUG -ggdb -L/win32dev/misc/wget/out64/lib -L/win32dev/misc/wget/out64/lib -lmetalink -lunistring -liconv -L/win32dev/misc/wget/out64/lib -lcares -L/win32dev/misc/wget/out64/lib -lpcre2-8 -L/win32dev/misc/wget/out64/lib -lssl -lcrypto -L/win32dev/misc/wget/out64/lib -lz -L/win32dev/misc/wget/out64/lib -lpsl -lidn2 -lunistring -liconv -lws2_32 -lole32 -lcrypt32 -lexpat -L/win32dev/misc/wget/out64/lib -lgpgme -lassuan -lgpg-error ftp-opie.o mswindows.o openssl.o http-ntlm.o ../lib/libgnu.a -lws2_32 -lws2_32 -lws2_32 -lws2_32 -lws2_32 -lws2_32 /win32dev/misc/wget/out64/lib/libiconv.a /win32dev/misc/wget/out64/lib/libunistring.a -lws2_32Copyright (C) 2015 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later&lt;http://www.gnu.org/licenses/gpl.html&gt;.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Originally written by Hrvoje Niksic &lt;hniksic@xemacs.org&gt;.Please send bug reports and questions to &lt;bug-wget@gnu.org&gt;. 尝试使用wget时，可以在终端输入wget 网址把目标链接下载到当前目录下，也可以输入wegt -p 指定目录 网址把目标链接下载到指定目录下。 2. 下载安装Wireshark参考资料：win10安装抓包工具wireshark 在Wireshark的官网下载地址中，在Stable Release中选择符合你计算机型号的安装包，我Windows10 64位电脑选择的是 Windows Installer (64-bit)，双击下载的.exe文件进行安装。 如果你仅仅只是为了完成课程实验，在安装的过程当中可以一路无脑next，在选择安装路径时可以更改为你想要的路径。 3.开始实验Step 1-3打开Wireshark，界面如下图所示，选择WLAN，点击捕获-选项。 在捕获选项界面，仅勾选WLAN，取消其他接口的混杂，在下方绿色的部分输入tcp port 80，使用“tcp端口80”筛选器启动捕获。 打开cmd终端，抓包一个网站，这里选择的是https://www.baidu.com/，网页获取完成后，立刻在Wireshark点击左上角的停止（红色正方形），显示如下图。 找到上方Protocol为HTTP，且Info是GET的，点击蓝色部分的Hypertext，可以看到整个窗口的最下方显示415 byte(s)，这是HTTP的实际有效开销。 接下来分别查看以太网（Ethernet）、IP、TCP占用的字节，分别如下为14 types、20 types、20 types。 由此，可以回答实验报告中的第一个 turn in：Step 3: Packet StructureTurn-in: Hand in your packet drawing. Step 4Protocol Overhead指的是协议开销，由于协议本身的报头等内容也需要占用一定的空间，用来标识该种协议、报文内各个字段的含义等信息，这种内容就是协议开销了。下载的包从一个Info中带有SYN，ACK信号的包开始，到下面第一个遇到的HTTP包后面的TCP包为止。 由此，可以回答实验报告中的第二个 turn in：Your estimate of download protocol overhead as defined above. Tell us whether you find this overhead to be significant.协议开销一共有 66+54+469+66=665字节HTTP有效开销一共有415字节，415/665≈62.41%，协议开销占比较小。 Step 5点击中间那一栏的以太网和IP，分别可以从Type和Protocol中找到第五步问题的答案。 由此，可以回答实验报告中的第三个 turn in： Which Ethernet header field is the demultiplexing key that tells it the next higher layer is IP? What value is used in this field to indicate “IP”?以太网报头字段是Type，对应的值是0x0800。 Which IP header field is the demultiplexing key that tells it the next higher layer is TCP? What value is used in this field to indicate “TCP”?IP报头字段是Protocol，对应的值是6。","link":"/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Labexercise1-1-Protocol-Layers/"},{"title":"基于Icarus5.x的主题美化改造","text":"看了下网上的教程，Hexo Icarus主题的美化改造大部分是基于2.x/3.x，用的都是ejs文件，而Icarus在4.x版本之后就用jsx文件进行编写了，网上那些美化的代码也不能完全适用，即使在Icarus官网4.x美化的教程中，也有一部分配置文件和5.x不一致，因此我打算写一个博客来记录下我给Icarus5.0.0美化的过程。 一些有用但不完全有用的资料这些资料大部分基于Icarus4.x主题，有一定的参考价值，但在一些小细节上有一定出入。 Icarus用户指南 Icarus 主题自定义 hexo更换icarus主题和美化 到 ICARUS 中去 —— 记对 Icarus 主题的使用及微调 给博文添加ReadMore在Icarus还是ejs的时代，可以根据这位大佬的教程来编写ejs文件实现自动添加ReamMore的效果，但是在5.0版本中，我只能自己手动在博文里添加ReadMore。在_config.icarus.yml文件中添加以下代码： 123#read more auto_excerpt: enable: true 然后在你的博客md里面你想要的位置手动添加&lt;!--more--&gt;。 添加访客地球小组件 功能：展示页面的总浏览量/页面浏览人来源的的热力图/同时在线人的地址标签 地址：RevolverMaps官网 找到.\\themes\\icarus\\layout\\common\\scripts.jsx，在return部分做出如下修改： 12345678910111213 return &lt;Fragment&gt; &lt;script src={cdn('jquery', '3.3.1', 'dist/jquery.min.js')}&gt;&lt;/script&gt; &lt;script src={cdn('moment', '2.22.2', 'min/moment-with-locales.min.js')}&gt;&lt;/script&gt; {clipboard &amp;&amp; &lt;script src={cdn('clipboard', '2.0.4', 'dist/clipboard.min.js')} defer&gt;&lt;/script&gt;} &lt;script dangerouslySetInnerHTML={{ __html: `moment.locale(&quot;${language}&quot;);` }}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: embeddedConfig }}&gt;&lt;/script&gt; &lt;script src={url_for('/js/column.js')}&gt;&lt;/script&gt; &lt;Plugins site={site} config={config} page={page} helper={helper} head={false} /&gt; &lt;script src={url_for('/js/main.js')} defer&gt;&lt;/script&gt; &lt;script src={url_for('/js/clicklove.js')} defer={true}&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;color=&quot;220,220,220&quot; opacity='0.7' zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;+ &lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; &lt;/Fragment&gt;; 添加的那一行代码为： 1&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 然后在.\\themes\\icarus\\layout\\widget中新建map.jsx文件，把以下代码复制到这个文件中： 12345678910111213const { Component } = require('inferno');const gravatrHelper = require('hexo-util').gravatar;const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');class Profile extends Component { render() { return &lt;Fragment&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; &lt;/Fragment&gt;; }}module.exports = Profile; 最后打开Icarus的全局配置文件_config.icarus.yml，找到widgets栏，添加如下代码： 1234# 地球小组件- type: map position: right 主页是三栏，点开文章变两栏主要参考了这位大佬的教程，具体过程比较坎坷，为了省事你可以把.\\themes\\icarus\\layout\\layout.jsx整体替换为以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const { Component } = require('inferno');const classname = require('hexo-component-inferno/lib/util/classname');const Head = require('./common/head');const Navbar = require('./common/navbar');const Widgets = require('./common/widgets');const Footer = require('./common/footer');const Scripts = require('./common/scripts');const Search = require('./common/search');module.exports = class extends Component { render() { const { site, config, page, helper, body } = this.props; const language = page.lang || page.language || config.language; const columnCount = Widgets.getColumnCount(config.widgets, config, page); if(page.path==='index.html'){ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; } else{ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; } }}; 给文章添加黏性目录和访问量黏性目录在toc.js文件中大概213行处做如下修改： hexo\\node_modules\\hexo-component-inferno\\lib\\view\\widget\\toc.js123456 var css = '#toc .menu-list &gt; li &gt; a.is-active + .menu-list { display: block; }' + '#toc .menu-list &gt; li &gt; a + .menu-list { display: none; }';- return (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card widget&quot;, [(0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card-content&quot;, (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;menu&quot;, [(0, _inferno.createVNode)(1, &quot;h3&quot;, &quot;menu-label&quot;, this.props.title, 0), this.renderToc(toc, showIndex)], 0), 2), collapsed ? (0, _inferno.createVNode)(1, &quot;style&quot;, null, null, 1, {+ return (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card widget is-3-column-toc&quot;, [(0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card-content&quot;, (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;menu&quot;, [(0, _inferno.createVNode)(1, &quot;h3&quot;, &quot;menu-label&quot;, this.props.title, 0), this.renderToc(toc, showIndex)], 0), 2), collapsed ? (0, _inferno.createVNode)(1, &quot;style&quot;, null, null, 1, { &quot;dangerouslySetInnerHTML&quot;: { __html: css } 并在style.styl中增加以下代码： .\\themes\\icarus\\source\\css\\style.styl12345678/* 黏性目录 */.is-1-column-toc /* 如当前列数为1，则目录采用原来的样式 */.is-2-column-toc, .is-3-column-toc /* 如当前列数为2或3，则目录采用粘性布局 */ position: sticky position: -webkit-sticky top: 0 z-index: 1 访问量将主题配置文件_config.icarus.yml的 plugins &gt; busuanzi 设置为 true 即可 给文章添加评论区官方文档Icarus用户指南 - 用户评论插件提供了十多种可以适配Icarus的评论插件，在对比了安全性和易上手度之后，我选择的是Waline评论区插件。 （1）按照Waline官方文档快速上手创建LeanCloud应用和Vercel项目，在Vercel 部署 (服务端)这一步中选择GitHub登录，项目库选择你博客所在的仓库。 （2）对于Waline插件的引入，在.\\themes\\icarus\\layout\\common\\scripts.jsx的return部分添加以下代码： 1&lt;script src=&quot;//cdn.jsdelivr.net/npm/@waline/client&quot;&gt;&lt;/script&gt; （3）将你Vercel项目的”服务器地址“(Server URL)复制到主题配置的对应配置项中。 _config.icarus.yml123456789101112131415161718192021comment: type: waline server_url: https://your-domain.vercel.app lang: zh-CN # 可选填 visitor: false # 可选填 emoji: # 可选填 - 'https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo' dark: auto # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 required_meta: [] # 可选填 login: enable # 可选填 avatar: mp # 可选填 word_limit: 0 # 可选填 page_size: 10 # 可选填 avatar_cdn: 'https://sdn.geekzu.org/avatar/' # 可选填 avatar_force: false # 可选填 highlight: true # 可选填 math_tag_support: false # 可选填 copyright: true # 可选填 locale: # 可选填 placeholder: 'Comment here...' tips： 对于Waline插件的更多了解和样式设计可以参照官方文档客户端介绍。 自定义网站的logo和favicon可以搜索在线制图网站生成你的图标和logo，这里推荐LOGO神器，在这里可以只能生成各种好看的图标和logo，但是生成后需要购买会员来下载文件（不过你可以把生成的图片直接截图再抠图就是了）。 将生成的图片转化为svg格式推荐onlineconvertfree，这个网站可以免费进行图片格式的转换，下载转换后的图片也非常方便。","link":"/2022/03/15/%E5%9F%BA%E4%BA%8EIcarus5-x%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%94%B9%E9%80%A0/"},{"title":"编译原理与设计-Lab2-编译器认知实验","text":"本实验主要的内容为在 Linux 平台上安装和运行工业界常用的编译器 GCC 和LLVM，如果系统中没有安装，则需要首先安装编译器，安装完成后编写简单的测试程序，使用编译器编译，并观察中间输出结果。 一、实验目的和内容 实验目的本实验的目的是了解工业界常用的编译器 GCC 和 LLVM，熟悉编译器的安装和使用过程，观察编译器工作过程中生成的中间文件的格式和内容，了解编译器的优化效果，为编译器的学习和构造奠定基础。 实验内容本实验主要的内容为在 Linux 平台上安装和运行工业界常用的编译器 GCC 和LLVM，如果系统中没有安装，则需要首先安装编译器，安装完成后编写简单的测试程序，使用编译器编译，并观察中间输出结果。 实验环境处理器 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz 1.99 GHz机带 RAM 16.0 GB (15.9 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Ubuntu 20.04.3 LTS内存 8GB硬盘（SCSI）100GLinux内核 Linux 5.15.2 二、实验的具体过程和步骤 1. 编译器安装12sudo apt-get install llvm sudo apt-get install clang 2. 编写测试程序单个程序1234#include &lt;stdio.h&gt; int main(){ printf(&quot;HelloWorld\\n&quot;); } 多个程序cal.c12345678#include &lt;stdio.h&gt; int add(int a,int b); int main(){ int num1, num2; scanf(&quot;%d %d&quot;,&amp;num1,&amp;num2); int res = add(num1,num2); printf(&quot;%d\\n&quot;, res); } add.c123#include &quot;add.h&quot; int add(int num1, int num2){ return num1+num2;} 3. 运行编译器进行观测GCC查看编译器版本12gcc -v gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04) 使用GCC编译链接单个文件1gcc -o hello hello.c 使用GCC编译多个文件1gcc -o cal cal.c add.c 查看预处理结果1gcc -E hello.c -o hello.i 查看语法分析树1gcc -fdump-tree-all hello.c 使用ls -ltr命令，可以看到执行命令后生成的文件。 查看中间代码生成结果1gcc -fdump-rtl-all hello.c 使用ls -ltr命令，可以看到执行命令后生成的文件。 查看生成的目标代码（汇编代码）1gcc -o hello.asm -S hello.c LLVM查看编译器版本12345clang -v clang version 10.0.0-4ubuntu1 Target: x86_64-pc-linux-gnu Thread model: posix InstalledDir: /usr/bin 使用LLVM编译单个文件1clang -o hello hello.c 使用LLVM编译链接多个文件1clang -o cal cal.c add.c 查看编译流程和阶段1clang -ccc-print-phases hello.c -c 查看词法分析结果1clang hello.c -fsyntax-only -Xclang -dump-tokens 查看词法分析结果21clang hello.c -fsyntax-only -Xclang -dump-raw-tokens 查看语法分析结果1lang -fsyntax-only -Xclang -ast-dump hello.c 查看语义分析结果21clang hello.c -fsyntax-only -Xclang -ast-view 查看编译优化的结果1clang hello.c -S -mllvm -print-after-all 查看生成的目标代码结果1clang hello.c -S 三、运行结果分析 1. GCC运行结果分析gcc编译的大概步骤是：词法分析 –&gt; 语法分析 –&gt; 生成语法树 –&gt; 高级gimple –&gt; 低级gimple –&gt; cfg –&gt; ssa –&gt;RTL –&gt;目标代码(汇编代码)。 预处理结果运行gcc -E hello.c -o hello.i生成的hello.i文件就是hello.ｃ经过预处理后的文件，一个简单的四行程序，在经过预处理后，多出了许多额外的变量和函数等。 语法分析树输入命令后产生的文件较多，其文件命名格式均为filename.c.t.name。 将其中的005.gimple､008.lower､014.printf与源文件进行对比,可以看到: 在005.gimple中,main函数转换为了高端gimple,在这一部分中,程序以函数为单位进行转化,将函数内部的变量以及编译器创建的临时变量都提高到最开始的位置,并将函数的执行语句集中到了一起,其顺序与语法树中所表现的顺序一致｡ 在008.lower中,gimple用lower动作,将高层次的gimple解析成了低层次,此过程主要完成了数据合并､代码合并和返回语句合并｡ 014.printf是低层次gimple转换为cfg的中间代码,cfg的主要作用是在低端gimple的基础上将语句分成几个基本块(basic block),在基本块内,代码是顺序执行的,不存在跳转语句,如果有跳转语句,则放在块的最后,保证跳转只发生在块与块之间,即在gimple中,指令跳转的语句就是基本块的边界｡ cfg转换为ssa则是为每个变量增加一个版本号,用于数据流的优化,其结构和地段fimple相同｡ 中间结果及目标代码使用命令后产生的文件较多，在中间结果中，为了保证同一段代码在不同平台都可以顺利运行，GCC提供了RTL这种中间形式的汇编语言，将所有优化都基于RTL完成，之后再转变为针对不同硬件平台的汇编代码，RTL生成的目标代码也就是汇编代码。 2. LLVM运行结果分析在进行编译时，返回的结果如上图所示，其中： ０：获得源代码ｃ语言文件。 １：预处理阶段，做出相应的处理，包括宏的替换、头文件的导入等。 ２：编译阶段。 ３：通过后端进行汇编前的处理。 ４：汇编链接。 词法分析这一步，源代码被切割成了一个个Token，比如左右括号、字符串等，可以看到词法分析２仅包含头文件的词法分词结果，而词法分析仅包括对源文件的词法分析结果。 语法分析语法分析主要检验程序的语法是否正确，而后将节点抽象为语法树AST。 查看编译优化结果生成中间代码IR，代码生成器会将语法树自顶向下遍历逐步翻译成LLVM IR，此过程中LLVM会进行优化工作，也可以设置优化级别-01，-02，-03等。 生成汇编文件下图为源文件和生成的汇编代码的对比： 四、GCC与LLVM对比分析 1. 汇编文件对比源文件均为c语言的HelloWorld，下图分别为gcc的汇编文件和llvm的汇编文件。 2. 优化编译由于HolleWorld的优化空间不大，此处采用第一个实验中的快排程序QSort.cpp作为源码，选择对规模为10000的逆序数组进行顺序排列，时间复杂度为O(n²)。在两个编译器中分别使用-O0（默认）、-O1、-O2、-O3进行优化编译，每组实验重复五次取消耗时间的平均值作为运行效率，进行对比。 GCC优化编译以下步骤运行五次求平均值，四种优化的耗时分别为：238477.8、68093.2、50332、46271.6。 LLVM优化编译以下步骤运行五次求平均值，四种优化的耗时分别为：174027.8、22891、33568.2、34258.2。 GCC和LLVM优化编译对比从下图中可以看出，LLVM的优化效率明显高于GCC，但是对于快排这样少循环多递归的程序，LLVM中-O2和-O3的优化效率反而不如-O1，但这三者的优化效率都远远高于默认的-O0。 五、实验心得体会 在本次实验中，我新接触到了一种工业界常用的编译器LLVM，在对比之后才发现，LLVM的编译优化效率远高于GCC。通过本次实验，我进一步了解到了编译器编译的原理和过程，为我接下来对编译器的学习奠定了基础。","link":"/2022/03/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab2-%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%A4%E7%9F%A5%E5%AE%9E%E9%AA%8C/"},{"title":"编译原理与设计-Lab1-程序设计语言认知","text":"分别使用 C/C++、Java、Python 和 Haskell 实现快速排序，对采用这几种语言实现的编程效率，程序的规模，程序的运行效率进行对比分析。 一、实验目的和内容 实验目的了解程序设计语言的发展历史，了解不同程序设计语言的各自特点；感受编译执行和解释执行两种不同的执行方式，初步体验语言对编译器设计的影响，为后续编译程序的设计和开发奠定良好的基础。 实验内容分别使用 C/C++、Java、Python 和 Haskell 实现快速排序，对采用这几种语言实现的编程效率，程序的规模，程序的运行效率进行对比分析。 实验环境处理器 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz 1.99 GHz机带 RAM 16.0 GB (15.9 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Windows10 二、实验的具体过程和步骤 实验分为三种情况：1. 普通情况下，对10000个取值区间在1-10000的不重复随机数进行快速排序。 在最坏情况下，对含有1000个元素的降序数组进行升序快速排序。 在最坏情况下，对含有10000个元素的降序数组进行升序快速排序。 1. C++语言编译器版本12C:\\Users\\hp\\Desktop&gt;gcc --version gcc (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;math.h&gt; #include &lt;algorithm&gt; using namespace std; /* N为实验规模，O为实验模式 对不重复的随机数快排的规模为 N = 10000 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 */ #define N 10000 #define O 2 const int MaxN = 1e4 + 10; int a[MaxN], b[MaxN]; //b[i]里面是1-10000不重复的随机数 //求随机数 void ran(){ srand((unsigned)time(NULL)); //初始化随机种子 for(int i = 0; i &lt; 10000; ++i){ a[i] = i + 1; } int index, temp, rest = 10000; for(int i = 0; i &lt; 10000; ++i) { index = rand() % rest; b[i] = a[index]; temp = a[index]; a[index] = a[rest - 1]; a[rest - 1] = temp; rest--; } } //快速排序 void quickSort(int *array, int left, int right) { if(left &gt;= right) return; if(left &lt; right) { int low = left, high = right; int key = array[left]; while(low &lt; high) { while(low &lt; high &amp;&amp; key &lt;= array[high]) high--; array[low] = array[high]; while(low &lt; high &amp;&amp; key &gt;= array[low]) low++; array[high] = array[low]; } array[low] = key; quickSort(array, left, low - 1); quickSort(array, low + 1, right); } } //模式判断 void fill(int arr[]){ //随机数组 if(O == 1){ for (int i = 0; i &lt; N;i++){ arr[i] = b[i]; if(i &lt; 10){ printf(&quot;%d &quot;, arr[i]); //输出前十个随机数 } } } //降序数组 if(O == 2){ for (int i = 0; i &lt; N; ++i) { arr[i] = N - i; } } } int main(){ int arr[N+10]; ran(); fill(arr); int start = clock(); int end = 0; int time = 0; quickSort(arr , 0 , N-1); end = clock(); time = end - start; if(O == 1) printf(&quot;N = 10000, the time of random array is : %d ms\\n&quot;,time); if(O == 2 &amp;&amp; N == 10000) printf(&quot;N = 10000, the time of descending array is : %d ms\\n&quot;,time); if(O == 2 &amp;&amp; N == 1000) printf(&quot;N = 1000, the time of descending array is : %d ms\\n&quot;,time); } 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次12C:\\Users\\hp\\Desktop&gt;gcc -o QSort QSort.cpp C:\\Users\\hp\\Desktop&gt;QSort.exe 2. Java编译器版本123456C:\\Users\\hp\\Desktop&gt;javac --version javac 16 C:\\Users\\hp\\Desktop&gt;java --version java 16 2021-03-16 Java(TM) SE Runtime Environment (build 16+36-2231) Java HotSpot(TM) 64-Bit Server VM (build 16+36-2231, mixed mode, sharing) 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList; public class QSort { /** * N为实验规模，O为实验模式 * 对不重复的随机数快排的规模为 N = 10000 * 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 * O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 */ static int O = 2; static int N = 1000; //模式判断 public static void fill(int[] arr){ ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); int num1 = 10000; for(int i = 1; i &lt; num1 + 1; i++){ list1.add(i); } if (O == 1) { for(int i = 0; i &lt; num1; i++){ //把list1中的数随机存入arr int val = (int)(Math.random()*list1.size()); Object obj = list1.get(val); arr[i] = list1.get(val); list1.remove(obj); //输出前十个随机数 if(i &lt; 10){ if(i == 0) System.out.print(&quot;[&quot;); if(i &lt; 9) System.out.print(arr[i] + &quot; &quot;); if(i == 9) System.out.print(arr[i] + &quot;] &quot;); } } } if(O == 2){ for (int i = 0; i &lt; N; i++) { arr[i] = N - i; } } } //快速排序 public static void quickSort(int []array, int left, int right) { if(left &gt;= right) return; if(left &lt; right) { int low = left, high = right; int key = array[left]; while(low &lt; high) { while(low &lt; high &amp;&amp; key &lt;= array[high]) high--; array[low] = array[high]; while(low &lt; high &amp;&amp; key &gt;= array[low]) low++; array[high] = array[low]; } array[low] = key; quickSort(array, left, low - 1); quickSort(array, low + 1, right); } } public static void main(String[] args){ int[] arr = new int[N]; fill(arr); long start = System.nanoTime(); quickSort(arr,0 , N-1); long end = System.nanoTime(); long time = (end - start) / 1000000; if(O == 1){ System.out.println(&quot;N = 10000, the time of random array is : &quot; + time + &quot; ms&quot;); } if(O == 2){ System.out.println(&quot;N = &quot; + N + &quot;, the time of descending array is : &quot; + time + &quot; ms&quot;); } } } 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次12C:\\Users\\hp\\Desktop&gt;javac QSort.java C:\\Users\\hp\\Desktop&gt;java QSort 3. Python编译器版本12C:\\Users\\hp\\Desktop&gt;python --version Python 3.7.4 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import time import sys import random sys.setrecursionlimit(100000) ''''' N为实验规模，O为实验模式 对不重复的随机数快排的规模为 N = 10000 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 ''' N = 10000 O = 2 def partition(arr, low, high): i = (low - 1) # 最小元素索引 pivot = arr[high] for j in range(low, high): # 当前元素小于或等于 pivot if arr[j] &lt;= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort(array, left, right): while left &lt; right: mid = partition(array, left, right) if mid - left &lt; right - mid: quicksort(array, left, mid - 1) left = mid + 1 else: quicksort(array, mid+1, right) right = mid - 1 def main(): arr = [0] * 10010 if O == 1: # 生成10000个不重复随机数 arr = random.sample(range(1, 10005), 10000) print(arr[:10]) # 输出前十个随机数 quicksort(arr, 0, N - 1) # print(arr[:10]) # 输出排序后的前十个数 if O == 2: # 降序数组 for i in range(0, N): arr[i] = N - i # print(arr[:10]) # 测试排序是否成功 quicksort(arr, 0, N - 1) # print(arr[:10]) start = time.time() main() end = time.time() cost_time = (end - start) * 1000 if O == 1: print(&quot;Python: N = 10000, the time of random array is : %f ms&quot; % cost_time) if O == 2 and N == 10000: print(&quot;Python: N = 10000, the time of descending array is : %f ms&quot; % cost_time) if O == 2 and N == 1000: print(&quot;Python: N = 1000, the time of descending array is : %f ms&quot; % cost_time) 每更换一次实验情况，都在终端运行8次1C:\\Users\\hp\\Desktop&gt;python QSort.py 4. Haskell编译器版本123456C:\\Users\\hp&gt;stack --version Version 2.7.3, Git revision 7927a3aec32e2b2e5e4fb5be76d0d50eddcc197f x86_64 hpack-0.34.4 C:\\Users\\hp&gt;stack exec -- ghc --version The Glorious Glasgow Haskell Compilation System, version 8.10.7 C:\\Users\\hp&gt;stack exec -- ghci GHCi, version 8.10.7: https://www.haskell.org/ghc/ :? for help 源代码123456789101112131415161718192021222324252627282930313233343536import Data.List import System.CPUTime import Text.Printf import System.Random quickSort :: (Ord a)=&gt;[a]-&gt;[a] quickSort [] =[] quickSort (x:xs)= let smaller=[a|a&lt;-xs,a&lt;=x] bigger=[a|a&lt;-xs,a&gt;x] in quickSort smaller ++[x]++quickSort bigger main = do g &lt;- newStdGen let list1 = take 10000 . nub $ (randomRs (1,10000) g :: [Int]) let list2 = [10000,9999..1] let list3 = [1000,999..1] let list = take 10 list1 let o = 1 -- o == 1是对随机数排序, o == 2是对降序数组进行升序排序 start &lt;- getCPUTime let qlist = quickSort list3 --对不重复10000个随机数进行排序是list1, 对规模为10000/1000的降序数组进行升序排序分别是list2和list3 end &lt;- getCPUTime let len = maximum qlist if o == 1 then print list --输出前十个随机数 else printf &quot;&quot; let ok = take 10 qlist printf &quot;The first ten arranged numbers are: &quot; print ok --输出排序后结果的前十位, 防止快排程序被优化掉 end2 &lt;- getCPUTime let diff = fromIntegral (end - start) / (10^9) if o == 1 then printf &quot;N = 10000, the time of random array without output is : %0.3f ms\\n&quot; (diff :: Double) else printf &quot;N = %d, the time of descending array without output is : %0.3f ms\\n&quot; (len::Int) (diff :: Double) let diff2 = fromIntegral (end2 - start) / (10^9) printf &quot;the time of outputing the resule of QSort is : %0.3f ms\\n&quot; (diff2 :: Double) 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次1C:\\Users\\hp&gt; stack runhaskell &quot;c:\\Users\\hp\\Desktop\\QSort.hs&quot; 三、运行效果截图 1. 普通情况对10000个取值区间在1-10000的不重复随机数进行快速排序，对于随机排列的数组，输出前10个数以确定其随机性，运行8次取平均值。 C++语言快速排序平均运行时间：2.000ms Java快速排序平均运行时间：2.875ms Python快速排序平均运行时间：116.261ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：7722.656ms 2. 最坏情况小规模对含有1000个元素的降序数组[1000,999,998,…,2,1]进行升序快速排序。 C++语言快速排序平均运行时间：2.000ms Java快速排序平均运行时间：4.875ms Python快速排序平均运行时间：123.921ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：394.531ms 3. 最坏情况大规模对含有10000个元素的降序数组[10000,9999,9998,…,2,1]进行升序快速排序。 C++语言快速排序平均运行时间：237.500ms Java快速排序平均运行时间：111.500ms Python快速排序平均运行时间：13294.012ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：41859.375ms 四、语言易用性和程序规模对比分析 1. 语言易用性语言的学习难度：Python &lt;= Java &lt;= C &lt;&lt; Haskell 。C语言： 编程入门语言，在写程序的时候，会更加习惯c的写法和各种基础操作，但同时c的链表指针和内存管理也具有一定的复杂性。Java： Java的语法和c有一定的相似之处，有c和面向对象作为基础，Java很好理解，而且Java一些函数的功能也非常强大，有自动内存管理，和c比较具有一定的简洁性。Python： Python入门简单易懂，如果有c的基础，Python很快就能被掌握，Python的语法更加简明清晰，程序主体更简洁，学习难度较低。Haskell： 由于大多程序员都是以c这种命令式语言作为基础的，Haskell这种纯函数式语言会让人感觉一时难以理解，它的概念、语法和我们以往接触到的程序都是截然不同的，需要用和我们习惯不同的方式去学习应用。 语言的编程效率：Haskell &lt;= C &lt;= Java &lt;&lt; Python 。C语言： 大多数程序员习惯的基础语言，但和Java/Python相比缺少一定的框架，更适合开发小型项目。在特定情况下，C更容易使开发者最大程度的提示程序运行效率。Java： 大多数大型项目都是基于Java 的相关框架开发的，对于大型项目Java的效率显然更高，而且也会减少各种bug发生的可能性。Python： Python的编程效率是最高的，因为他的语法最简单直白，在人工智能和神经网络领域，使用Python可以更好的提高效率、减少代码规模。而且Python强大的功能也可以让它只用一行代码就完成一个复杂的功能。Haskell： Haskell很少应用于工程，加上对纯函数语言和函数思维的不熟悉，导致Haskell的门槛较高，相应编程效率也会降低，但是在学界尤其是数学领域，其在数学逻辑证明上有独到的优势。总结： 语言的编程效率主要取决于你所要实现的项目，在不同的项目上选用合适的语言工具是提高效率的关键。在本次的快排项目中，C、Java、Python并没有太大的差别，Haskell编程效率最慢也仅仅是因为本人对这种语言的不熟悉导致的，在纯数学逻辑的计算中，Haskell的编程效率反而可能会是最高的。 2. 程序规模Haskell &lt;&lt; Python &lt; Java &lt; C程序的总体规模依次递减，QSort函数部分的代码规模Python、Java、C相差不大，Haskell不管是代码总体规模还是QSort函数部分代码规模都远小于另外三种。 五、程序运行性能对比分析（保留到小数点后三位） 普通情况和小规模的最坏数据中，效率上C语言最快，其次是Java；对于解释型语言，Python较快，Haskell效率最低。但是当数据规模较大时，Java的效率会高于c语言。 六、实验心得体会 本次实验我选择了快速排序这一题目，主要的难点有两个：一是在写Python代码时，由于语言本身和系统的限制，即时用到了“sys.setrecursionlimit(100000)”，但是在运行大规模最坏数据时，程序递归到5584次左右依然会停止，因此修改了快速排序的语法结构，进行了尾递归优化，以缩减堆栈。此外就是初学Haskell语言的困难，面对一种全新的纯函数式语言，最开始是茫然的，但是在查阅了无数资料后，我也发现了这种语言独有的魅力，也更新了自身的思维方式。","link":"/2022/03/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab1-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%AE%A4%E7%9F%A5/"}],"tags":[{"name":"编译原理与设计","slug":"编译原理与设计","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Hexo &amp; Icarus","slug":"Hexo-Icarus","link":"/tags/Hexo-Icarus/"}],"categories":[{"name":"Guide","slug":"Guide","link":"/categories/Guide/"},{"name":"Experimental report","slug":"Experimental-report","link":"/categories/Experimental-report/"},{"name":"Life &amp; Hello-world","slug":"Life-Hello-world","link":"/categories/Life-Hello-world/"},{"name":"Hello-world","slug":"Life-Hello-world/Hello-world","link":"/categories/Life-Hello-world/Hello-world/"}]}