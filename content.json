{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/08/hello-world/"},{"title":"Windows10 和 VSCode 上Haskell的安装与环境搭建","text":"在Windows10 和 VSCode 上安装搭建Haskell环境 参考资料：【VS Code】Windows10下VS Code配置Haskell语言环境在整体的环境安装配置过程中，多处涉及到github链接和需要翻墙的链接，部分校园网可能会链接失败，可以尝试手机热点。 1. 下载安装Stack打开Stack官方文档，选择Windows 64-bit Installer进行下载，双击下载下来的exe文件进行安装，可以自定义C盘路径，但是要以管理员身份运行。 Windows 64-bit Installer 安装步骤1 安装过程中，还会自动将Stack添加到用户环境变量 PATH 中，同时会设置 STACK_ROOT=C:\\sr（安装程序的默认选项，记住这个路径，后面要考），安装完成后，可以在cmd终端输入命令“stack –help”来检验安装是否成功。 安装步骤2 2. 安装GHC（麻烦bug多）Stack可以用于管理Haskell编译器GHC和Haskell库，因此使用Stack安装GHC。 由于Haskell的生态和版本支持不是很好，如果你直接安装而不固定版本号，软件包的安装就容易引起冲突，导致各种依赖项间的不兼容。访问这个网站，查看Haskell最新的LTS，然后锁定在这个LTS上，此处我选择的是最新的LTS 18.27。 Stackage 一些辅助理解的概念（和配置环境关系不大，你可以不看）： Hackage是Haskell社区的开源软件包仓库 The Haskell Package Repository ，可以发布库和程序，或者使用Cabal-install这样的软件包管理器下载和安装软件包。 Stackage是 Stable Haskell package sets 的缩写，即稳定一致的Haskell包集合。它是一个Haskell软件包子集的发行版，来自Hackage并和它一同被社区构建起来。Stackage存在的意义在于，它提供了兼容一致且稳定的Haskell包集，每个包都选择了一个特定版本以满足软件包集合的自洽性，从而解决包版本的冲突问题、顺利构建和运行项目。 Stackage提供和维护了一堆不同的大版本，每个大版本都对应一个兼容一致稳定的Haskell包集，或者说是一个LTS Long Term Service ，被社区长期支持。我们选定了一个LTS之后，在下载安装时只可能发生某个包不存在的情况，就算出现冲突也能通过Stack来轻松解决，不会埋下一大堆“地雷”。 2.1 配置stack在cmd终端执行stack install，会发现下载经常失败。 1(ConnectionFailure user error (Network.Socket.gai_strerror not supported: 11004)) 这是因为下载过程中的一个网址需要翻墙才能访问，在不翻墙的情况下，需要进行换源才可以下载成功。 参考资料：关于stack换源的问题 其中提到了两个清华源的网址，“可以同时使用 TUNA 的 Stackage 源 + Hackage 源来解决”，分别是stackage 镜像使用帮助和hackage 镜像使用帮助。 在stackage 镜像使用帮助中提到“本镜像推荐与 TUNA 的 Hackage 镜像配合使用”，因此两个镜像源都需要添加。 2.2 换源：在终端输入stack --version查看stack版本，然后在上述两个源链接中分别找到对应版本的源进行更换，我的stack版本是2.7.3，在这里说明我的换源过程： （1）下载 stackage 镜像中提示的文件： stackage 镜像 下载图片下方蓝色链接的global-hints.yaml文件，在系统中找到对应的文件夹，不同下载路径对应的文件夹不同，此处的路径就是上文提及的记下来要考的路径： 默认路径下载时，直接在c盘路径输入%APPDATA%，然后回车就可以打开对应文件夹。 %APPDATA% 我下载的时候更改了默认路径，所以要修改的配置文件是%STACK_ROOT%\\config.yaml，配置文件对应的路径是上面记住要考的哪个C:\\sr\\config.yaml。 （2）更换源现在你已经找到了对应的目录，在此目录下的pantry文件夹内放入刚刚下载好的global-hints.yaml文件，并更改 stack（默认路径）或sr（我更改的路径）目录下的config.yaml，在此文件中增添两个镜像源中对应版本的代码，我的版本是2.7.3： stack hackage 即在config.yaml中增加以下代码： 123456789101112131415161718192021222324package-indices: - download-prefix: http://mirrors.tuna.tsinghua.edu.cn/hackage/ hackage-security: keyids: - 0a5c7ea47cd1b15f01f5f51a33adda7e655bc0f0b0615baa8e271f4c3351e21d - 1ea9ba32c526d1cc91ab5e5bd364ec5e9e8cb67179a471872f6e26f0ae773d42 - 280b10153a522681163658cb49f632cde3f38d768b736ddbc901d99a1a772833 - 2a96b1889dc221c17296fcc2bb34b908ca9734376f0f361660200935916ef201 - 2c6c3627bd6c982990239487f1abd02e08a02e6cf16edb105a8012d444d870c3 - 51f0161b906011b52c6613376b1ae937670da69322113a246a09f807c62f6921 - 772e9f4c7db33d251d5c6e357199c819e569d130857dc225549b40845ff0890d - aa315286e6ad281ad61182235533c41e806e5a787e0b6d1e7eef3f09d137d2e9 - fe331502606802feac15e514d9b9ea83fee8b6ffef71335479a2e68d84adc6b0 key-threshold: 3 # number of keys required # ignore expiration date, see https://github.com/commercialhaskell/stack/pull/4614 ignore-expiry: nosetup-info-locations: [&quot;http://mirrors.tuna.tsinghua.edu.cn/stackage/stack-setup.yaml&quot;]urls: latest-snapshot: http://mirrors.tuna.tsinghua.edu.cn/stackage/snapshots.jsonsnapshot-location-base: https://mirrors.tuna.tsinghua.edu.cn/stackage/stackage-snapshots/ （3）配置GHC回到终端，运行命令stack --resolver lts-18.27 setup下载lts，成功代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253C:\\Users\\hp&gt;stack --resolver lts-18.27 setupWarning: http://mirrors.tuna.tsinghua.edu.cn/stackage/stack-setup.yaml: Unrecognized field in GHCDownloadInfo: versionPreparing to install GHC to an isolated location.This will not interfere with any system-level installation.Already downloaded.Downloaded 7z.dll.Downloaded 7z.exe.Decompressing ghc-8.10.7.tar.xz...7-Zip 9.20 Copyright (c) 1999-2010 Igor Pavlov 2010-11-18Processing archive: C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.10.7.tar.xzExtracting ghc-8.10.7.tarEverything is OkSize: 2768711680Compressed: 434126144Extracting ghc-8.10.7.tar...Extracted total of 10342 files from ghc-8.10.7.tarGHC installed to C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.10.7\\Downloaded msys2-20210604.Already downloaded.Already downloaded.Decompressing msys2-20210604.tar.xz...7-Zip 9.20 Copyright (c) 1999-2010 Igor Pavlov 2010-11-18Processing archive: C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\msys2-20210604.tar.xzExtracting msys2-20210604.tarEverything is OkSize: 390021120Compressed: 99822772Extracting msys2-20210604.tar...Extracted total of 17688 files from msys2-20210604.tarCopying skeleton files.These files are for the users to personalise their msys2 experience.They will never be overwritten nor automatically updated.'./.bashrc' -&gt; '/home/hp/.bashrc''./.bash_logout' -&gt; '/home/hp/.bash_logout''./.bash_profile' -&gt; '/home/hp/.bash_profile''./.inputrc' -&gt; '/home/hp/.inputrc''./.profile' -&gt; '/home/hp/.profile'\u001b[0mstack will use a sandboxed GHC it installed\u001b[0m\u001b[0mFor more information on paths, see 'stack path' and 'stack exec env'\u001b[0m\u001b[0mTo use this GHC and packages outside of a project, consider using:\u001b[0m\u001b[0mstack ghc, stack ghci, stack runghc, or stack exec\u001b[0m 测试一下GHC是否安装成功： 1234567C:\\Users\\hp&gt;stack exec -- ghc --versionThe Glorious Glasgow Haskell Compilation System, version 8.10.7C:\\Users\\hp&gt;stack exec -- ghciGHCi, version 8.10.7: https://www.haskell.org/ghc/ :? for helpPrelude&gt; :quitLeaving GHCi. 到此，我们已经有了一个可用的Stack和GHC（芜湖撒花）。 3.配置VSCode3.1 安装插件由于VSCode中的一部分插件版本过老，和新版本的GHC不匹配，因此下载旧版本的GHC做备用，一般来说LTS9不会出现冲突。 在终端执行以下命令进行安装，并检测安装是否成功： 12stack --resolver lts-9.21 setupstack --compiler ghc-8.0.2 exec -- ghc --version 配置完成后，在VSCode扩展中安装以下插件： Haskell ghc-mod Haskell-linter Haskell Syntax Highlighting Haskelly Haskell Code Runner 然后在终端配置插件，分别执行以下命令（这一步所需时间较长，如果一次没配置完，第二次重新打开终端时，需要重新输入chcp 65001） 1234chcp 65001stack --resolver lts-9.21 install ghc-modstack --resolver lts-9.21 install hlintstack --resolver lts-9.21 install intero QuickCheck stack-run 以上这些安装完成后，终端显示如下，不用管那个Warning，但是要记住他那个路径 C:\\Users\\hp\\AppData\\Roaming\\local\\bin，Stack安装的所有扩展应该都在这个路径中，这个路径在配置settings.json时需要用到。 安装完成 3.2 配置Haskell语言学习环境（1）配置ghc-mod、hlint、Code Runner在VSCode中打开 文件（File）- 首项选（Preferences）- 设置（Settings），点击下图红圈的位置，打开settings.json。 设置 settings.json 在settings.json文件中加入以下代码，注意在第8行末尾增加逗号，其中Haskell-linter配置的路径就是上面那个提示的路径。 12345678 /* Haskell ghc-mod配置 */ &quot;haskell.ghcMod.executablePath&quot;: &quot;stack&quot;, /* Haskell-linter配置 */ &quot;haskell.hlint.executablePath&quot;: &quot;C:\\\\Users\\\\hp\\\\AppData\\\\Roaming\\\\local\\\\bin\\\\hlint.exe&quot;, /* code-runner配置 */ &quot;code-runner.executorMap&quot;: { &quot;haskell&quot;: &quot;cd $dir &amp;&amp; stack runhaskell $fileName&quot;}, settings-over （2）配置Haskell由于使用的是Stack，下列配置项要么添加到全局配置文件 $STACK_ROOT\\config.yaml 中，要么添加到项目配置文件 stack.yaml 中： 12ghc-options: '$everything': -haddock # 一个从带注释的Haskell源代码自动生成文档的工具 4. 尝试使用经过以上操作，haskell的环境基本搭建完毕，写一个简单的Hello World来测试是否成功。在VSCode运行.hs文件基本有以下三种方式： 在终端输入stack runhaskell &quot;.hs文件路径&quot;（最稳定）。 点击右上角的小三角运行按钮。 点击最下面蓝色行用红笔圈出的Run File运行文件。 可以看到成功输出了Hello World。 爷终于成功了哈哈哈哈哈 tips:在实际使用的过程中，想引用import System.Random时却发现系统提示没有这个模块，在查找了无数资料后，终于在这个网站中找到了可行的解决方案，可以尝试在终端输入下面的第一行代码，如果无效则尝试第二行代码： 12stack install randomstack ghci --package random 附：一些个人认为比较有用的Haskell入门资料 Haskell - 条件判断 Haskell系列（三）列表","link":"/2022/03/10/Windows10-%E5%92%8C-VSCode-%E4%B8%8AHaskell%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"计算机网络实验 Labexercise1-1 Protocol Layers","text":"前言：本博客包含Windows10下安装wget、Wireshark。 一些有用的链接： Labexercise1-1 Protocol Layers翻译 wireshark练习及答案lab-protocol-layers.docx Wireshark抓包使用指南 山东大学计算机网络实验 一些有用的提示：开始实验进行抓包时，校园网环境下的同学不建议使用一些 [ 上网不涉密涉密不上网 ] 的校园网进行抓包，可能会导致抓不到包捏 :)（找了半天bug，气死我了） 1. 下载安装wget参考资料：wget for windows 下载与安装 点击此链接，选择合适的版本下载.exe文件，然后把下好的.exe文件放在C:/windows/system32目录下即可。 在cmd终端输入wget --version，显示如下，则安装成功: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849C:\\Users\\hp\\Desktop&gt;wget --versionGNU Wget 1.21.2 built on mingw32.+cares +digest +gpgme +https +ipv6 +iri +large-file +metalink -nls+ntlm +opie +psl +ssl/opensslWgetrc: /win32dev/misc/wget/out64/etc/wgetrc (system)Compile: x86_64-w64-mingw32-gcc -DHAVE_CONFIG_H -DSYSTEM_WGETRC=&quot;/win32dev/misc/wget/out64/etc/wgetrc&quot; -DLOCALEDIR=&quot;/win32dev/misc/wget/out64/share/locale&quot; -I. -I../../src -I../lib -I../../lib -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DCARES_STATICLIB -I/win32dev/misc/wget/out64/include -DPCRE2_STATIC -I/win32dev/misc/wget/out64/include -DHAVE_LIBSSL -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DNDEBUG -ggdbLink: x86_64-w64-mingw32-gcc -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DCARES_STATICLIB -I/win32dev/misc/wget/out64/include -DPCRE2_STATIC -I/win32dev/misc/wget/out64/include -DHAVE_LIBSSL -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DNDEBUG -ggdb -L/win32dev/misc/wget/out64/lib -L/win32dev/misc/wget/out64/lib -lmetalink -lunistring -liconv -L/win32dev/misc/wget/out64/lib -lcares -L/win32dev/misc/wget/out64/lib -lpcre2-8 -L/win32dev/misc/wget/out64/lib -lssl -lcrypto -L/win32dev/misc/wget/out64/lib -lz -L/win32dev/misc/wget/out64/lib -lpsl -lidn2 -lunistring -liconv -lws2_32 -lole32 -lcrypt32 -lexpat -L/win32dev/misc/wget/out64/lib -lgpgme -lassuan -lgpg-error ftp-opie.o mswindows.o openssl.o http-ntlm.o ../lib/libgnu.a -lws2_32 -lws2_32 -lws2_32 -lws2_32 -lws2_32 -lws2_32 /win32dev/misc/wget/out64/lib/libiconv.a /win32dev/misc/wget/out64/lib/libunistring.a -lws2_32Copyright (C) 2015 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later&lt;http://www.gnu.org/licenses/gpl.html&gt;.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Originally written by Hrvoje Niksic &lt;hniksic@xemacs.org&gt;.Please send bug reports and questions to &lt;bug-wget@gnu.org&gt;. 尝试使用wget时，可以在终端输入wget 网址把目标链接下载到当前目录下，也可以输入wegt -p 指定目录 网址把目标链接下载到指定目录下。 2. 下载安装Wireshark参考资料：win10安装抓包工具wireshark 在Wireshark的官网下载地址中，在Stable Release中选择符合你计算机型号的安装包，我Windows10 64位电脑选择的是 Windows Installer (64-bit)，双击下载的.exe文件进行安装。 如果你仅仅只是为了完成课程实验，在安装的过程当中可以一路无脑next，在选择安装路径时可以更改为你想要的路径。 3.开始实验Step 1-3打开Wireshark，界面如下图所示，选择WLAN，点击捕获-选项。 在捕获选项界面，仅勾选WLAN，取消其他接口的混杂，在下方绿色的部分输入tcp port 80，使用“tcp端口80”筛选器启动捕获。 打开cmd终端，抓包一个网站，这里选择的是https://www.baidu.com/，网页获取完成后，立刻在Wireshark点击左上角的停止（红色正方形），显示如下图。 找到上方Protocol为HTTP，且Info是GET的，点击蓝色部分的Hypertext，可以看到整个窗口的最下方显示415 byte(s)，这是HTTP的实际有效开销。 接下来分别查看以太网（Ethernet）、IP、TCP占用的字节，分别如下为14 types、20 types、20 types。 由此，可以回答实验报告中的第一个 turn in：Step 3: Packet StructureTurn-in: Hand in your packet drawing. Step 4Protocol Overhead指的是协议开销，由于协议本身的报头等内容也需要占用一定的空间，用来标识该种协议、报文内各个字段的含义等信息，这种内容就是协议开销了。下载的包从一个Info中带有SYN，ACK信号的包开始，到下面第一个遇到的HTTP包后面的TCP包为止。 由此，可以回答实验报告中的第二个 turn in：Your estimate of download protocol overhead as defined above. Tell us whether you find this overhead to be significant.协议开销一共有 66+54+469+66=665字节HTTP有效开销一共有415字节，415/665≈62.41%，协议开销占比较小。 Step 5点击中间那一栏的以太网和IP，分别可以从Type和Protocol中找到第五步问题的答案。 由此，可以回答实验报告中的第三个 turn in： Which Ethernet header field is the demultiplexing key that tells it the next higher layer is IP? What value is used in this field to indicate “IP”?以太网报头字段是Type，对应的值是0x0800。 Which IP header field is the demultiplexing key that tells it the next higher layer is TCP? What value is used in this field to indicate “TCP”?IP报头字段是Protocol，对应的值是6。","link":"/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Labexercise1-1-Protocol-Layers/"},{"title":"基于Icarus5.x的主题美化改造","text":"看了下网上的教程，Hexo Icarus主题的美化改造大部分是基于2.x/3.x，用的都是ejs文件，而Icarus在4.x版本之后就用jsx文件进行编写了，网上那些美化的代码也不能完全适用，即使在Icarus官网4.x美化的教程中，也有一部分配置文件和5.x不一致，因此我打算写一个博客来记录下我给Icarus5.0.0美化的过程。 一些有用但不完全有用的资料这些资料大部分基于Icarus4.x主题，有一定的参考价值，但在一些小细节上有一定出入。 Icarus用户指南 Icarus 主题自定义 hexo更换icarus主题和美化 到 ICARUS 中去 —— 记对 Icarus 主题的使用及微调 给博文添加ReadMore在Icarus还是ejs的时代，可以根据这位大佬的教程来编写ejs文件实现自动添加ReamMore的效果，但是在5.0版本中，我只能自己手动在博文里添加ReadMore。在_config.icarus.yml文件中添加以下代码： 123#read more auto_excerpt: enable: true 然后在你的博客md里面你想要的位置手动添加&lt;!--more--&gt;。 添加访客地球小组件 功能：展示页面的总浏览量/页面浏览人来源的的热力图/同时在线人的地址标签 地址：RevolverMaps官网 找到.\\themes\\icarus\\layout\\common\\scripts.jsx，在return部分做出如下修改： 12345678910111213 return &lt;Fragment&gt; &lt;script src={cdn('jquery', '3.3.1', 'dist/jquery.min.js')}&gt;&lt;/script&gt; &lt;script src={cdn('moment', '2.22.2', 'min/moment-with-locales.min.js')}&gt;&lt;/script&gt; {clipboard &amp;&amp; &lt;script src={cdn('clipboard', '2.0.4', 'dist/clipboard.min.js')} defer&gt;&lt;/script&gt;} &lt;script dangerouslySetInnerHTML={{ __html: `moment.locale(&quot;${language}&quot;);` }}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: embeddedConfig }}&gt;&lt;/script&gt; &lt;script src={url_for('/js/column.js')}&gt;&lt;/script&gt; &lt;Plugins site={site} config={config} page={page} helper={helper} head={false} /&gt; &lt;script src={url_for('/js/main.js')} defer&gt;&lt;/script&gt; &lt;script src={url_for('/js/clicklove.js')} defer={true}&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;color=&quot;220,220,220&quot; opacity='0.7' zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;+ &lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; &lt;/Fragment&gt;; 添加的那一行代码为： 1&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 然后在.\\themes\\icarus\\layout\\widget中新建map.jsx文件，把以下代码复制到这个文件中： 12345678910111213const { Component } = require('inferno');const gravatrHelper = require('hexo-util').gravatar;const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');class Profile extends Component { render() { return &lt;Fragment&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; &lt;/Fragment&gt;; }}module.exports = Profile; 最后打开Icarus的全局配置文件_config.icarus.yml，找到widgets栏，添加如下代码： 1234# 地球小组件- type: map position: right 主页是三栏，点开文章变两栏主要参考了这位大佬的教程，具体过程比较坎坷，为了省事你可以把.\\themes\\icarus\\layout\\layout.jsx整体替换为以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const { Component } = require('inferno');const classname = require('hexo-component-inferno/lib/util/classname');const Head = require('./common/head');const Navbar = require('./common/navbar');const Widgets = require('./common/widgets');const Footer = require('./common/footer');const Scripts = require('./common/scripts');const Search = require('./common/search');module.exports = class extends Component { render() { const { site, config, page, helper, body } = this.props; const language = page.lang || page.language || config.language; const columnCount = Widgets.getColumnCount(config.widgets, config, page); if(page.path==='index.html'){ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; } else{ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; } }}; 给文章添加黏性目录和访问量黏性目录在toc.js文件中大概213行处做如下修改： hexo\\node_modules\\hexo-component-inferno\\lib\\view\\widget\\toc.js123456 var css = '#toc .menu-list &gt; li &gt; a.is-active + .menu-list { display: block; }' + '#toc .menu-list &gt; li &gt; a + .menu-list { display: none; }';- return (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card widget&quot;, [(0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card-content&quot;, (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;menu&quot;, [(0, _inferno.createVNode)(1, &quot;h3&quot;, &quot;menu-label&quot;, this.props.title, 0), this.renderToc(toc, showIndex)], 0), 2), collapsed ? (0, _inferno.createVNode)(1, &quot;style&quot;, null, null, 1, {+ return (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card widget is-3-column-toc&quot;, [(0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card-content&quot;, (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;menu&quot;, [(0, _inferno.createVNode)(1, &quot;h3&quot;, &quot;menu-label&quot;, this.props.title, 0), this.renderToc(toc, showIndex)], 0), 2), collapsed ? (0, _inferno.createVNode)(1, &quot;style&quot;, null, null, 1, { &quot;dangerouslySetInnerHTML&quot;: { __html: css } 并在style.styl中增加以下代码： .\\themes\\icarus\\source\\css\\style.styl12345678/* 黏性目录 */.is-1-column-toc /* 如当前列数为1，则目录采用原来的样式 */.is-2-column-toc, .is-3-column-toc /* 如当前列数为2或3，则目录采用粘性布局 */ position: sticky position: -webkit-sticky top: 0 z-index: 1 访问量将主题配置文件_config.icarus.yml的 plugins &gt; busuanzi 设置为 true 即可 给文章添加评论区官方文档Icarus用户指南 - 用户评论插件提供了十多种可以适配Icarus的评论插件，在对比了安全性和易上手度之后，我选择的是Waline评论区插件。 （1）按照Waline官方文档快速上手创建LeanCloud应用和Vercel项目，在Vercel 部署 (服务端)这一步中选择GitHub登录，项目库选择你博客所在的仓库。 （2）对于Waline插件的引入，在.\\themes\\icarus\\layout\\common\\scripts.jsx的return部分添加以下代码： 1&lt;script src=&quot;//cdn.jsdelivr.net/npm/@waline/client&quot;&gt;&lt;/script&gt; （3）将你Vercel项目的”服务器地址“(Server URL)复制到主题配置的对应配置项中。 _config.icarus.yml123456789101112131415161718192021comment: type: waline server_url: https://your-domain.vercel.app lang: zh-CN # 可选填 visitor: false # 可选填 emoji: # 可选填 - 'https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo' dark: auto # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 required_meta: [] # 可选填 login: enable # 可选填 avatar: mp # 可选填 word_limit: 0 # 可选填 page_size: 10 # 可选填 avatar_cdn: 'https://sdn.geekzu.org/avatar/' # 可选填 avatar_force: false # 可选填 highlight: true # 可选填 math_tag_support: false # 可选填 copyright: true # 可选填 locale: # 可选填 placeholder: 'Comment here...' tips： 对于Waline插件的更多了解和样式设计可以参照官方文档客户端介绍。 自定义网站的logo和favicon可以搜索在线制图网站生成你的图标和logo，这里推荐LOGO神器，在这里可以智能生成各种好看的图标和logo，但是生成后需要购买会员来下载文件（不过你可以把生成的图片直接截图再抠图就是了）。 将生成的图片转化为svg格式推荐onlineconvertfree，这个网站可以免费进行图片格式的转换，下载转换后的图片也非常方便。","link":"/2022/03/15/%E5%9F%BA%E4%BA%8EIcarus5-x%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%94%B9%E9%80%A0/"},{"title":"编译原理与设计-Lab2-编译器认知实验","text":"本实验主要的内容为在 Linux 平台上安装和运行工业界常用的编译器 GCC 和LLVM，如果系统中没有安装，则需要首先安装编译器，安装完成后编写简单的测试程序，使用编译器编译，并观察中间输出结果。 一、实验目的和内容 实验目的本实验的目的是了解工业界常用的编译器 GCC 和 LLVM，熟悉编译器的安装和使用过程，观察编译器工作过程中生成的中间文件的格式和内容，了解编译器的优化效果，为编译器的学习和构造奠定基础。 实验内容本实验主要的内容为在 Linux 平台上安装和运行工业界常用的编译器 GCC 和LLVM，如果系统中没有安装，则需要首先安装编译器，安装完成后编写简单的测试程序，使用编译器编译，并观察中间输出结果。 实验环境处理器 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz 1.99 GHz机带 RAM 16.0 GB (15.9 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Ubuntu 20.04.3 LTS内存 8GB硬盘（SCSI）100GLinux内核 Linux 5.15.2 二、实验的具体过程和步骤 1. 编译器安装12sudo apt-get install llvm sudo apt-get install clang 2. 编写测试程序单个程序1234#include &lt;stdio.h&gt; int main(){ printf(&quot;HelloWorld\\n&quot;); } 多个程序cal.c12345678#include &lt;stdio.h&gt; int add(int a,int b); int main(){ int num1, num2; scanf(&quot;%d %d&quot;,&amp;num1,&amp;num2); int res = add(num1,num2); printf(&quot;%d\\n&quot;, res); } add.c123#include &quot;add.h&quot; int add(int num1, int num2){ return num1+num2;} 3. 运行编译器进行观测GCC查看编译器版本12gcc -v gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04) 使用GCC编译链接单个文件1gcc -o hello hello.c 使用GCC编译多个文件1gcc -o cal cal.c add.c 查看预处理结果1gcc -E hello.c -o hello.i 查看语法分析树1gcc -fdump-tree-all hello.c 使用ls -ltr命令，可以看到执行命令后生成的文件。 查看中间代码生成结果1gcc -fdump-rtl-all hello.c 使用ls -ltr命令，可以看到执行命令后生成的文件。 查看生成的目标代码（汇编代码）1gcc -o hello.asm -S hello.c LLVM查看编译器版本12345clang -v clang version 10.0.0-4ubuntu1 Target: x86_64-pc-linux-gnu Thread model: posix InstalledDir: /usr/bin 使用LLVM编译单个文件1clang -o hello hello.c 使用LLVM编译链接多个文件1clang -o cal cal.c add.c 查看编译流程和阶段1clang -ccc-print-phases hello.c -c 查看词法分析结果1clang hello.c -fsyntax-only -Xclang -dump-tokens 查看词法分析结果21clang hello.c -fsyntax-only -Xclang -dump-raw-tokens 查看语法分析结果1lang -fsyntax-only -Xclang -ast-dump hello.c 查看语义分析结果21clang hello.c -fsyntax-only -Xclang -ast-view 查看编译优化的结果1clang hello.c -S -mllvm -print-after-all 查看生成的目标代码结果1clang hello.c -S 三、运行结果分析 1. GCC运行结果分析gcc编译的大概步骤是：词法分析 –&gt; 语法分析 –&gt; 生成语法树 –&gt; 高级gimple –&gt; 低级gimple –&gt; cfg –&gt; ssa –&gt;RTL –&gt;目标代码(汇编代码)。 预处理结果运行gcc -E hello.c -o hello.i生成的hello.i文件就是hello.ｃ经过预处理后的文件，一个简单的四行程序，在经过预处理后，多出了许多额外的变量和函数等。 语法分析树输入命令后产生的文件较多，其文件命名格式均为filename.c.t.name。 将其中的005.gimple､008.lower､014.printf与源文件进行对比,可以看到: 在005.gimple中,main函数转换为了高端gimple,在这一部分中,程序以函数为单位进行转化,将函数内部的变量以及编译器创建的临时变量都提高到最开始的位置,并将函数的执行语句集中到了一起,其顺序与语法树中所表现的顺序一致｡ 在008.lower中,gimple用lower动作,将高层次的gimple解析成了低层次,此过程主要完成了数据合并､代码合并和返回语句合并｡ 014.printf是低层次gimple转换为cfg的中间代码,cfg的主要作用是在低端gimple的基础上将语句分成几个基本块(basic block),在基本块内,代码是顺序执行的,不存在跳转语句,如果有跳转语句,则放在块的最后,保证跳转只发生在块与块之间,即在gimple中,指令跳转的语句就是基本块的边界｡ cfg转换为ssa则是为每个变量增加一个版本号,用于数据流的优化,其结构和地段fimple相同｡ 中间结果及目标代码使用命令后产生的文件较多，在中间结果中，为了保证同一段代码在不同平台都可以顺利运行，GCC提供了RTL这种中间形式的汇编语言，将所有优化都基于RTL完成，之后再转变为针对不同硬件平台的汇编代码，RTL生成的目标代码也就是汇编代码。 2. LLVM运行结果分析在进行编译时，返回的结果如上图所示，其中： ０：获得源代码ｃ语言文件。 １：预处理阶段，做出相应的处理，包括宏的替换、头文件的导入等。 ２：编译阶段。 ３：通过后端进行汇编前的处理。 ４：汇编链接。 词法分析这一步，源代码被切割成了一个个Token，比如左右括号、字符串等，可以看到词法分析２仅包含头文件的词法分词结果，而词法分析仅包括对源文件的词法分析结果。 语法分析语法分析主要检验程序的语法是否正确，而后将节点抽象为语法树AST。 查看编译优化结果生成中间代码IR，代码生成器会将语法树自顶向下遍历逐步翻译成LLVM IR，此过程中LLVM会进行优化工作，也可以设置优化级别-01，-02，-03等。 生成汇编文件下图为源文件和生成的汇编代码的对比： 四、GCC与LLVM对比分析 1. 汇编文件对比源文件均为c语言的HelloWorld，下图分别为gcc的汇编文件和llvm的汇编文件。 2. 优化编译由于HolleWorld的优化空间不大，此处采用第一个实验中的快排程序QSort.cpp作为源码，选择对规模为10000的逆序数组进行顺序排列，时间复杂度为O(n²)。在两个编译器中分别使用-O0（默认）、-O1、-O2、-O3进行优化编译，每组实验重复五次取消耗时间的平均值作为运行效率，进行对比。 GCC优化编译以下步骤运行五次求平均值，四种优化的耗时分别为：238477.8、68093.2、50332、46271.6。 LLVM优化编译以下步骤运行五次求平均值，四种优化的耗时分别为：174027.8、22891、33568.2、34258.2。 GCC和LLVM优化编译对比从下图中可以看出，LLVM的优化效率明显高于GCC，但是对于快排这样少循环多递归的程序，LLVM中-O2和-O3的优化效率反而不如-O1，但这三者的优化效率都远远高于默认的-O0。 五、实验心得体会 在本次实验中，我新接触到了一种工业界常用的编译器LLVM，在对比之后才发现，LLVM的编译优化效率远高于GCC。通过本次实验，我进一步了解到了编译器编译的原理和过程，为我接下来对编译器的学习奠定了基础。","link":"/2022/03/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab2-%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%A4%E7%9F%A5%E5%AE%9E%E9%AA%8C/"},{"title":"编译原理与设计-Lab1-程序设计语言认知","text":"分别使用 C/C++、Java、Python 和 Haskell 实现快速排序，对采用这几种语言实现的编程效率，程序的规模，程序的运行效率进行对比分析。 一、实验目的和内容 实验目的了解程序设计语言的发展历史，了解不同程序设计语言的各自特点；感受编译执行和解释执行两种不同的执行方式，初步体验语言对编译器设计的影响，为后续编译程序的设计和开发奠定良好的基础。 实验内容分别使用 C/C++、Java、Python 和 Haskell 实现快速排序，对采用这几种语言实现的编程效率，程序的规模，程序的运行效率进行对比分析。 实验环境处理器 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz 1.99 GHz机带 RAM 16.0 GB (15.9 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Windows10 二、实验的具体过程和步骤 实验分为三种情况：1. 普通情况下，对10000个取值区间在1-10000的不重复随机数进行快速排序。 在最坏情况下，对含有1000个元素的降序数组进行升序快速排序。 在最坏情况下，对含有10000个元素的降序数组进行升序快速排序。 1. C++语言编译器版本12C:\\Users\\hp\\Desktop&gt;gcc --version gcc (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;math.h&gt; #include &lt;algorithm&gt; using namespace std; /* N为实验规模，O为实验模式 对不重复的随机数快排的规模为 N = 10000 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 */ #define N 10000 #define O 2 const int MaxN = 1e4 + 10; int a[MaxN], b[MaxN]; //b[i]里面是1-10000不重复的随机数 //求随机数 void ran(){ srand((unsigned)time(NULL)); //初始化随机种子 for(int i = 0; i &lt; 10000; ++i){ a[i] = i + 1; } int index, temp, rest = 10000; for(int i = 0; i &lt; 10000; ++i) { index = rand() % rest; b[i] = a[index]; temp = a[index]; a[index] = a[rest - 1]; a[rest - 1] = temp; rest--; } } //快速排序 void quickSort(int *array, int left, int right) { if(left &gt;= right) return; if(left &lt; right) { int low = left, high = right; int key = array[left]; while(low &lt; high) { while(low &lt; high &amp;&amp; key &lt;= array[high]) high--; array[low] = array[high]; while(low &lt; high &amp;&amp; key &gt;= array[low]) low++; array[high] = array[low]; } array[low] = key; quickSort(array, left, low - 1); quickSort(array, low + 1, right); } } //模式判断 void fill(int arr[]){ //随机数组 if(O == 1){ for (int i = 0; i &lt; N;i++){ arr[i] = b[i]; if(i &lt; 10){ printf(&quot;%d &quot;, arr[i]); //输出前十个随机数 } } } //降序数组 if(O == 2){ for (int i = 0; i &lt; N; ++i) { arr[i] = N - i; } } } int main(){ int arr[N+10]; ran(); fill(arr); int start = clock(); int end = 0; int time = 0; quickSort(arr , 0 , N-1); end = clock(); time = end - start; if(O == 1) printf(&quot;N = 10000, the time of random array is : %d ms\\n&quot;,time); if(O == 2 &amp;&amp; N == 10000) printf(&quot;N = 10000, the time of descending array is : %d ms\\n&quot;,time); if(O == 2 &amp;&amp; N == 1000) printf(&quot;N = 1000, the time of descending array is : %d ms\\n&quot;,time); } 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次12C:\\Users\\hp\\Desktop&gt;gcc -o QSort QSort.cpp C:\\Users\\hp\\Desktop&gt;QSort.exe 2. Java编译器版本123456C:\\Users\\hp\\Desktop&gt;javac --version javac 16 C:\\Users\\hp\\Desktop&gt;java --version java 16 2021-03-16 Java(TM) SE Runtime Environment (build 16+36-2231) Java HotSpot(TM) 64-Bit Server VM (build 16+36-2231, mixed mode, sharing) 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList; public class QSort { /** * N为实验规模，O为实验模式 * 对不重复的随机数快排的规模为 N = 10000 * 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 * O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 */ static int O = 2; static int N = 1000; //模式判断 public static void fill(int[] arr){ ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); int num1 = 10000; for(int i = 1; i &lt; num1 + 1; i++){ list1.add(i); } if (O == 1) { for(int i = 0; i &lt; num1; i++){ //把list1中的数随机存入arr int val = (int)(Math.random()*list1.size()); Object obj = list1.get(val); arr[i] = list1.get(val); list1.remove(obj); //输出前十个随机数 if(i &lt; 10){ if(i == 0) System.out.print(&quot;[&quot;); if(i &lt; 9) System.out.print(arr[i] + &quot; &quot;); if(i == 9) System.out.print(arr[i] + &quot;] &quot;); } } } if(O == 2){ for (int i = 0; i &lt; N; i++) { arr[i] = N - i; } } } //快速排序 public static void quickSort(int []array, int left, int right) { if(left &gt;= right) return; if(left &lt; right) { int low = left, high = right; int key = array[left]; while(low &lt; high) { while(low &lt; high &amp;&amp; key &lt;= array[high]) high--; array[low] = array[high]; while(low &lt; high &amp;&amp; key &gt;= array[low]) low++; array[high] = array[low]; } array[low] = key; quickSort(array, left, low - 1); quickSort(array, low + 1, right); } } public static void main(String[] args){ int[] arr = new int[N]; fill(arr); long start = System.nanoTime(); quickSort(arr,0 , N-1); long end = System.nanoTime(); long time = (end - start) / 1000000; if(O == 1){ System.out.println(&quot;N = 10000, the time of random array is : &quot; + time + &quot; ms&quot;); } if(O == 2){ System.out.println(&quot;N = &quot; + N + &quot;, the time of descending array is : &quot; + time + &quot; ms&quot;); } } } 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次12C:\\Users\\hp\\Desktop&gt;javac QSort.java C:\\Users\\hp\\Desktop&gt;java QSort 3. Python编译器版本12C:\\Users\\hp\\Desktop&gt;python --version Python 3.7.4 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import time import sys import random sys.setrecursionlimit(100000) ''''' N为实验规模，O为实验模式 对不重复的随机数快排的规模为 N = 10000 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 ''' N = 10000 O = 2 def partition(arr, low, high): i = (low - 1) # 最小元素索引 pivot = arr[high] for j in range(low, high): # 当前元素小于或等于 pivot if arr[j] &lt;= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort(array, left, right): while left &lt; right: mid = partition(array, left, right) if mid - left &lt; right - mid: quicksort(array, left, mid - 1) left = mid + 1 else: quicksort(array, mid+1, right) right = mid - 1 def main(): arr = [0] * 10010 if O == 1: # 生成10000个不重复随机数 arr = random.sample(range(1, 10005), 10000) print(arr[:10]) # 输出前十个随机数 quicksort(arr, 0, N - 1) # print(arr[:10]) # 输出排序后的前十个数 if O == 2: # 降序数组 for i in range(0, N): arr[i] = N - i # print(arr[:10]) # 测试排序是否成功 quicksort(arr, 0, N - 1) # print(arr[:10]) start = time.time() main() end = time.time() cost_time = (end - start) * 1000 if O == 1: print(&quot;Python: N = 10000, the time of random array is : %f ms&quot; % cost_time) if O == 2 and N == 10000: print(&quot;Python: N = 10000, the time of descending array is : %f ms&quot; % cost_time) if O == 2 and N == 1000: print(&quot;Python: N = 1000, the time of descending array is : %f ms&quot; % cost_time) 每更换一次实验情况，都在终端运行8次1C:\\Users\\hp\\Desktop&gt;python QSort.py 4. Haskell编译器版本123456C:\\Users\\hp&gt;stack --version Version 2.7.3, Git revision 7927a3aec32e2b2e5e4fb5be76d0d50eddcc197f x86_64 hpack-0.34.4 C:\\Users\\hp&gt;stack exec -- ghc --version The Glorious Glasgow Haskell Compilation System, version 8.10.7 C:\\Users\\hp&gt;stack exec -- ghci GHCi, version 8.10.7: https://www.haskell.org/ghc/ :? for help 源代码123456789101112131415161718192021222324252627282930313233343536import Data.List import System.CPUTime import Text.Printf import System.Random quickSort :: (Ord a)=&gt;[a]-&gt;[a] quickSort [] =[] quickSort (x:xs)= let smaller=[a|a&lt;-xs,a&lt;=x] bigger=[a|a&lt;-xs,a&gt;x] in quickSort smaller ++[x]++quickSort bigger main = do g &lt;- newStdGen let list1 = take 10000 . nub $ (randomRs (1,10000) g :: [Int]) let list2 = [10000,9999..1] let list3 = [1000,999..1] let list = take 10 list1 let o = 1 -- o == 1是对随机数排序, o == 2是对降序数组进行升序排序 start &lt;- getCPUTime let qlist = quickSort list3 --对不重复10000个随机数进行排序是list1, 对规模为10000/1000的降序数组进行升序排序分别是list2和list3 end &lt;- getCPUTime let len = maximum qlist if o == 1 then print list --输出前十个随机数 else printf &quot;&quot; let ok = take 10 qlist printf &quot;The first ten arranged numbers are: &quot; print ok --输出排序后结果的前十位, 防止快排程序被优化掉 end2 &lt;- getCPUTime let diff = fromIntegral (end - start) / (10^9) if o == 1 then printf &quot;N = 10000, the time of random array without output is : %0.3f ms\\n&quot; (diff :: Double) else printf &quot;N = %d, the time of descending array without output is : %0.3f ms\\n&quot; (len::Int) (diff :: Double) let diff2 = fromIntegral (end2 - start) / (10^9) printf &quot;the time of outputing the resule of QSort is : %0.3f ms\\n&quot; (diff2 :: Double) 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次1C:\\Users\\hp&gt; stack runhaskell &quot;c:\\Users\\hp\\Desktop\\QSort.hs&quot; 三、运行效果截图 1. 普通情况对10000个取值区间在1-10000的不重复随机数进行快速排序，对于随机排列的数组，输出前10个数以确定其随机性，运行8次取平均值。 C++语言快速排序平均运行时间：2.000ms Java快速排序平均运行时间：2.875ms Python快速排序平均运行时间：116.261ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：7722.656ms 2. 最坏情况小规模对含有1000个元素的降序数组[1000,999,998,…,2,1]进行升序快速排序。 C++语言快速排序平均运行时间：2.000ms Java快速排序平均运行时间：4.875ms Python快速排序平均运行时间：123.921ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：394.531ms 3. 最坏情况大规模对含有10000个元素的降序数组[10000,9999,9998,…,2,1]进行升序快速排序。 C++语言快速排序平均运行时间：237.500ms Java快速排序平均运行时间：111.500ms Python快速排序平均运行时间：13294.012ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：41859.375ms 四、语言易用性和程序规模对比分析 1. 语言易用性语言的学习难度：Python &lt;= Java &lt;= C &lt;&lt; Haskell 。C语言： 编程入门语言，在写程序的时候，会更加习惯c的写法和各种基础操作，但同时c的链表指针和内存管理也具有一定的复杂性。Java： Java的语法和c有一定的相似之处，有c和面向对象作为基础，Java很好理解，而且Java一些函数的功能也非常强大，有自动内存管理，和c比较具有一定的简洁性。Python： Python入门简单易懂，如果有c的基础，Python很快就能被掌握，Python的语法更加简明清晰，程序主体更简洁，学习难度较低。Haskell： 由于大多程序员都是以c这种命令式语言作为基础的，Haskell这种纯函数式语言会让人感觉一时难以理解，它的概念、语法和我们以往接触到的程序都是截然不同的，需要用和我们习惯不同的方式去学习应用。 语言的编程效率：Haskell &lt;= C &lt;= Java &lt;&lt; Python 。C语言： 大多数程序员习惯的基础语言，但和Java/Python相比缺少一定的框架，更适合开发小型项目。在特定情况下，C更容易使开发者最大程度的提示程序运行效率。Java： 大多数大型项目都是基于Java 的相关框架开发的，对于大型项目Java的效率显然更高，而且也会减少各种bug发生的可能性。Python： Python的编程效率是最高的，因为他的语法最简单直白，在人工智能和神经网络领域，使用Python可以更好的提高效率、减少代码规模。而且Python强大的功能也可以让它只用一行代码就完成一个复杂的功能。Haskell： Haskell很少应用于工程，加上对纯函数语言和函数思维的不熟悉，导致Haskell的门槛较高，相应编程效率也会降低，但是在学界尤其是数学领域，其在数学逻辑证明上有独到的优势。总结： 语言的编程效率主要取决于你所要实现的项目，在不同的项目上选用合适的语言工具是提高效率的关键。在本次的快排项目中，C、Java、Python并没有太大的差别，Haskell编程效率最慢也仅仅是因为本人对这种语言的不熟悉导致的，在纯数学逻辑的计算中，Haskell的编程效率反而可能会是最高的。 2. 程序规模Haskell &lt;&lt; Python &lt; Java &lt; C程序的总体规模依次递减，QSort函数部分的代码规模Python、Java、C相差不大，Haskell不管是代码总体规模还是QSort函数部分代码规模都远小于另外三种。 五、程序运行性能对比分析（保留到小数点后三位） 普通情况和小规模的最坏数据中，效率上C语言最快，其次是Java；对于解释型语言，Python较快，Haskell效率最低。但是当数据规模较大时，Java的效率会高于c语言。 六、实验心得体会 本次实验我选择了快速排序这一题目，主要的难点有两个：一是在写Python代码时，由于语言本身和系统的限制，即时用到了“sys.setrecursionlimit(100000)”，但是在运行大规模最坏数据时，程序递归到5584次左右依然会停止，因此修改了快速排序的语法结构，进行了尾递归优化，以缩减堆栈。此外就是初学Haskell语言的困难，面对一种全新的纯函数式语言，最开始是茫然的，但是在查阅了无数资料后，我也发现了这种语言独有的魅力，也更新了自身的思维方式。","link":"/2022/03/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab1-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%AE%A4%E7%9F%A5/"},{"title":"功能性网站分享","text":"本文记录我在做项目时发现的一些实用的功能性网站，以便在打工搬砖的过程中提高效率，本文持续更新…… 图表类 在线制图线上快速绘制流程图、ER图等各种图。 图表秀线上绘制更优雅的图表，例如条形图、饼状图等。 Font Awesome、阿里图标库搜罗了一些现成的icon。 程序类 CodeInWord在Word中优雅的展示代码 | 代码高亮 | 格式化代码。 Markdown 官方教程一些Markdown的速查表、基本语法和扩展语法。 SM.MS快速给本地图片生成URL等，普通用户有免费的5GB空间储存转换的图片，可以购买会员升级空间（100G 59USD，约人民币375元，永久有效）。但是个人觉得免费的5GB够用了，平时的项目截图一张图片平均100KB，能存5000多张呢。不过在实操中发现，一篇文章如果使用较多的图片url，加载速度会很缓慢，如果在md文档中使用本地的相对路径插入图片，在博客上打开文章会很快。","link":"/2022/03/16/%E5%8A%9F%E8%83%BD%E6%80%A7%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/"},{"title":"软件工程-个人项目-数独游戏","text":"本次项目分为三个阶段 第1阶段：生成终局 第2阶段：求解数独 第3阶段：用户界面 项目详细代码和说明可以在我的GitHub项目仓库查看，欢迎关注我的GitHub呀 ヽ(✿ﾟ▽ﾟ)ノ PSP表格 PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟） Planning 计划 120 90 · Estimate · 估计这个任务需要多少时间 3600 4160 Development 开发 1800 2400 · Analysis · 需求分析 (包括学习新技术) 180 180 · 需求分析 (包括学习新技术) · 生成设计文档 60 30 · Design Review · 设计复审 (和同事审核设计文档) 60 40 · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 30 30 · Design · 具体设计 180 200 · Coding · 具体编码 720 750 · Code Review · 代码复审 90 60 · Test · 测试（自我测试，修改代码，提交修改） 120 120 Reporting 报告 120 180 · Test Report · 测试报告 40 30 · Size Measurement · 计算工作量 20 20 · Postmortem &amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 60 30 合计 3600 4160 第一阶段：生成终局一、解题思路首先上网查阅资料，了解数独游戏规则：标准数独是由一个给与了提示数字的9x9网格组成，每行、列、宫各自都要填上1-9的数字，要做到每行、列、宫里的数字都不重复。 宫是由3×3的小格子组成的。 在刚拿到题目后，我对于数独终局的生成思路还处于一种比较模糊的状态，初步的想法是先随机生成第一行1-9九个数字，在生成第二行时，每一个数字都与第一行对应列的数字相比较，不能与之重复，以此类推。但是在初步估计时间复杂度后发现，这种方法并不理想，于是上网查阅有关数独终局的资料来寻找数独的规律，试图降低时间复杂度。 经查阅资料可知，对于一个数独终局，第一行固定，从第二行开始，每行依次由第一行左移3、6、1、4、7、2、5、8位生成，则可以生成合格的一个数独终局。 我的学号尾号是9，第一个数字固定为 (0+9) % 9 + 1 = 1，所以通过对第一行进行全排列的方式就可以产生8！= 40320种终局。 此外，对于任意一个数独，第1-3行（列）、4-6行（列）、6-9行（列）中，任意两行（列）交换后数独仍然成立，在保证最左上角数字不变的前提下，可以交换4-6中任意两行，7-9中任意两行。 中间三行的顺序可以为：456、465、564、546、654、645最后三行的顺序可以为：789、798、879、897、987、978 共有8!×3!×3! = 1451520中终局，大于要求的1000000。 二、求解数独程序流程图 三、求解数独程序函数设计12345void swap(int&amp; a, int&amp; b); //交换两个数void create(int n); //生成n个数独终局并写入文件bool permutation(int* p); //排列组合第一行void flag(int f1, int f2); //中间和末尾三行的变换void output(int sudo[9][9], FILE* fp); //把生成的数独写入文件输出 其中主要函数 bool permutation() 代码设计如下： · bool permutation(int* p)该部分代码用于对第一行后八个数字进行全排列。 1234567891011121314151617181920bool permutation(int* p) { //从后往前找，发现后面的数大于前面的数，则停在后一个数 //若没有以上情况，则证明 8！种排列已排完 int i = 7; while (i &gt; 0 &amp;&amp; p[i] &lt; p[i - 1]) i--; if (i == 0) return false; //从后查到i，查到大于p[i - 1]的最小的数，记入k int k = i; for (int j = 7; j &gt;= i; j--) { if (p[j] &gt; p[i - 1] &amp;&amp; p[j] &lt; p[k]) k = j; } swap(p[k], p[i - 1]); //倒置p[last]到p[i] for (int j = 7, k = i; j &gt; k; j--, k++) { swap(p[j], p[k]); } return true;} 第二阶段：求解数独一、解题思路在刚拿到题目后，我最开始想到的是暴力求解，但是题目的范围是1-1000000道，暴力求解时间复杂度过高，在查找资料后采用深搜和剪枝的方法。 数独的求解主要参照了资料数独求解方法，对于空白格子，按照1-9的顺序尝试填入数字，看这个数字在所在行/列/九宫格中是否和其他格子重复，排除不符合要求的数字。如果最终发现1-9每一个数字都不符合要求，则可能是上一个格子填入错误，需要返回上一个空格尝试下一个数字。 二、求解数独程序流程图 三、求解数独程序函数设计1234void solve(const char* txt); //依次读取每个数独并求解void resolve(int row, int col); //求解数独的dfsbool isValid(int row, int col); //判断行、列、九宫格是否有重复void s_output(); //把求解的数独写入文件输出 其中主要函数 resolve() 和 isValid() 代码设计如下： · isValid(int row, int col)该部分代码主要用于深搜的剪枝，判断填入空格的数字是否合法：把数字填入空格时，该数字不能与所在行、列、九宫格重复，如果重复，则返回false，如果没有重复，则返回true。 1234567891011121314151617bool isValid(int row, int col) { int num = s_sudo[row][col]; for (int i = 0; i &lt; 9; i++) { //这一列有重复的 if (s_sudo[i][col] == num &amp;&amp; i != row)return false; } for (int j = 0; j &lt; 9; j++) { //这一行有重复的 if (s_sudo[row][j] == num &amp;&amp; j != col)return false; } int x = (row / 3) * 3; int y = (col / 3) * 3; for (int i = x; i &lt; x + 3; i++) { //所在九宫格有重复的 for (int j = y; j &lt; y + 3; j++) { if (s_sudo[i][j] == num &amp;&amp; i != row &amp;&amp; j != col)return false; } } return true;} · resolve(int row, int col)数独的求解部分采用深度优先搜索，为了减少搜索时间，使用 isValid() 剪枝，如果填入的数字不合法，则尝试下一个数字，直到找到合适的数字为止；如果不存在合法数字，则返回上一个空，重新填写。 在进行了性能分析报告后，发现此函数占用时间较多，为了进一步优化程序减少时间，还应该尽可能减少上一个空格填错数字的可能性，因此可以从空格最少的一行开始填写。以下是深搜函数的流程图和代码： 1234567891011121314151617181920212223242526272829303132333435363738394041void resolve(int row, int col) { if (isOK == 1)return; blank[row]--; for (int i = 1; i &lt; 10; i++) { s_sudo[row][col] = i; if (isValid(row, col)) { //这一行还有空格 if (blank[row] &gt; 0) { int j; for (j = 0; j &lt; 9; j++) { if (s_sudo[row][j] == 0)break; } resolve(row, j); } //这一行没有空格了 else { int next_row = -1; for (int k = 0; k &lt; 9; k++) { //找到下一个空白最少的一行 if (blank[k] == 0)continue; if (next_row == -1)next_row = k; if (blank[k] &lt; blank[next_row])next_row = k; } if (next_row == -1) { //数独没有空行了 isOK = 1; return; } int j; for (j = 0; j &lt; 9; j++) { if (s_sudo[next_row][j] == 0)break; } resolve(next_row, j); } if (isOK == 1)return; } } //9个数字都尝试完，没有符合要求的，证明上一个数字填错了，返回 s_sudo[row][col] = 0; blank[row]++; return;} 第三阶段：用户界面一、解题思路在Visual Studio 2019中新建 Windows 窗体应用项目，为游戏设计大体功能：新游戏、重新开始、提示、提交、退出。 （1）新游戏用户点击“新游戏”，数独棋盘随机生成新的数独题目，计时从0开始。用户可以在棋盘上的空格里填写数字1-9，或者按退格删除填写的数字。开始游戏后，用户可以选择重新开始、提示、提交、退出。用户每一次点击“新游戏”，棋盘上都会生成新的题目。 （2）重新开始用户点击“重新开始”，现在棋盘上已经填写的数字会被清空，用户可以重新开始计算这局数独，计时不会清零。 （3）提示用户点击“提示”，从棋盘第一个空开始依次扫描，当发现有填写错误的空时，错误的地方标红作为提示；如果在扫描出错误之前发现有空白的空，则显示此空的正确答案作为提示。每使用一次提示，总计时会增加五秒作为惩罚计时。 （4）提交用户点击“提示”，系统检测整个棋盘，如果用户还有空格未填写，提示数独未完成；如果填写完成但是与答案不符，提示数独填写有错误；如果用户填写与答案一致，则恭喜用户完成数独，同时停止计时，显示用户解出数独的时间。 （5）退出用户可以在任意时刻点击“退出”，点击后窗口会关闭。 二、用户界面顺序图 三、用户界面程序设计用户界面程序总共包含两个类，两个类中的函数分别如下： 12public partial class Form1 : Form //窗口界面public class sudoku //数独生成和求解 12345678910public Form1()private void Form1_Load(object sender, EventArgs e) //窗口private void Txt_KeyPress(object sender, KeyPressEventArgs e) //让用户只能输入数字1-9或退格键private void Init() //初始化数独棋盘private void button1_Click(object sender, EventArgs e) //点击开始新游戏private void Quit_Click(object sender, EventArgs e) //退出private void Submit_Click(object sender, EventArgs e) //点击提交并判断题目完成度private void Tips_Click(object sender, EventArgs e) //提示private void Restart_Click(object sender, EventArgs e) //重新开始本局private void timer1_Tick(object sender, EventArgs e) //计时器 12345public sudoku()public void flag(int f1, int f2) //中间和末尾三行的变换void output(int flag_mid, int flag_end) //把生成的数独根据变换写入question[,]，answer[,]public void b_blank() //给数独题目question[,]挖空public void create(int[] first) //生成初始数独终局并写入question[,]，answer[,] 关键功能代码详情如下： （1）生成数独题目和新游戏为了使题目具有随机性，且题库数量大于1000000，对于第一行的生成采用随机数的方法，随机生成1-9不重复的九个数，以此代替按顺序对第一行排列组合，关键代码如下： 1234567891011121314151617//生成数独第一行1-9随机数，每个数字各不重复 Random r = new Random(); for (int i = 0; i &lt; array.Length; i++) { array[i] = r.Next(1, 10); if (i &gt; 0) { for (int j = 0; j &lt; i; j++) { if (array[i] == array[j]) { i--; break; } } } } 在确定第一行之后，按照第一阶段生成数独终局的方法，通过对第一行进行不同位次的左移，生成初始数独终局。 为了保证变换的充足性，在生成数独终局的基础上，对于确定行交换的变量flag_mid、flag_end，采取生成1-6随机数的方式，来随机决定生成的数独终局是否进行4-6、7-9行的交换，代码如下： 12345678910111213//第j行为第一行左移shift[j]，变换出完整的数独 for (int j = 1; j &lt; 9; j++) { for (int k = 0; k &lt; 9; k++) { sudo[j, k] = sudo[0, ((k + shift[j - 1]) % 9)]; } } Random rand = new Random(); flag_mid = rand.Next(1, 7); flag_end = rand.Next(1, 7); output(flag_mid, flag_end); 确认最终的数独题目后，把数独终局存入sudoku类中的question[,]，answer[,]数组，answer[,]储存完整的数独终局作为答案，question[,]随机进行挖空，生成带空的数独题目，并且保证每个3×3的小九宫格都至少含有两个空，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940public void b_blank() { Random rdm = new Random(); int blank = rdm.Next(30, 61); //生成30 - 60 个空 //9个3X3，每个3X3的小棋盘中挖空不少于2个。 for (int i = 0; i &lt; 9; i++) { for (int j = 0; j &lt; 2; j++) { int position = rdm.Next(9); //选择3X3里空的位置 int x = i / 3 * 3 + position / 3; int y = i % 3 * 3 + position % 3; //如果这个位置没被挖空，则挖空，反之，再随机一个数 if (question[x, y] != 0) { question[x, y] = 0; blank--; } else { j--; continue; } } } //空还有剩余 while (blank &gt; 0) { int i = rdm.Next(9); int j = rdm.Next(9); if (question[i, j] != 0) //没有被挖空 { question[i, j] = 0; blank--; } } } 确认题目后，将数独题目传入新游戏的textbox[,]数组中，没有挖空的地方设置为只读模式，且底色设置为浅灰色，计时开始。代码和最终效果如下： 1234567891011121314151617181920212223242526272829//生成数独题目并挖空，将题目填入txetbox sudoku.create(array); for(int i = 0; i &lt; 9; i++) { for(int j = 0; j &lt; 9; j++) { textbox[i, j].Text = &quot;&quot;; //每点击一次新游戏，都要归零每一个空格 textbox[i, j].BackColor = Color.White; textbox[i, j].ReadOnly = false; if (sudoku.question[i, j] != 0) { textbox[i, j].Text = sudoku.question[i, j].ToString(); textbox[i, j].ReadOnly = true; textbox[i, j].BackColor = Color.FromArgb(220,220,220); } } } //开始新游戏时，重新开始计时 if (timer1.Enabled == true) { timer1.Enabled = false; label_h.Text = &quot;0&quot;; label_m.Text = &quot;0&quot;; label_s.Text = &quot;0&quot;; } timer1.Enabled = true; （2）重新开始扫描整个棋盘，把非只读模式的格子重新清空。代码和最终效果如下： 12345678910private void Restart_Click(object sender, EventArgs e) { for(int i = 0; i &lt; 9; i++) { for(int j = 0; j &lt; 9; j++) { if (textbox[i, j].ReadOnly == false) textbox[i, j].Text = &quot;&quot;; } } } （3）提示提示会根据用户的大题情况，提示答案或者提示错误，代码和最终效果如下： 1234567891011121314151617181920212223242526272829private void Tips_Click(object sender, EventArgs e) { flag_tips = 1; int e_flag = 0; //e_flag == 1 为提示完毕 for(int i = 0; i &lt; 9; i++) { for(int j = 0; j &lt; 9; j++) { //有空的地方则填上 if(textbox[i, j].Text == &quot;&quot;) { textbox[i, j].Text = sudoku.answer[i, j].ToString(); e_flag = 1; break; } //有错误则提示 if(textbox[i, j].Text != &quot;&quot; &amp;&amp; textbox[i, j].Text != sudoku.answer[i, j].ToString()) { textbox[i, j].BackColor = Color.Red; MessageBox.Show(&quot;标红地方填写错误！&quot;, &quot;提示&quot;); textbox[i, j].BackColor = Color.White; e_flag = 1; break; } } if (e_flag == 1) break; } } （4）提交根据用户不同的答题情况，提交效果分别如下图所示： （5）关于计时器设定每隔一秒触发一次time控件，每触发一次，秒数加一；如果使用了“提示”，秒数加五。把总共耗时的秒数换算成时分秒显示在三个Lable控件上，当点击新游戏时，三个显示时间的Label控件全部归零。代码如下： 123456789101112131415161718public Form1() { InitializeComponent(); Init(); //提交、提示、重新开始按钮不可用 Submit.Enabled = false; Restart.Enabled = false; Tips.Enabled = false; //初始化计时器 label_h.Text = &quot;0&quot;; label_m.Text = &quot;0&quot;; label_s.Text = &quot;0&quot;; timer1.Interval = 1000; label_tips.Text = &quot;tips：&quot; + &quot;\\n\\n&quot; + &quot;每使用一次提示&quot; + &quot;\\n\\n&quot; + &quot;总用时增加五秒&quot;; } 1234567891011121314151617181920212223242526272829303132333435363738private void timer1_Tick(object sender, EventArgs e) { int hour = Int32.Parse(label_h.Text); int min = Int32.Parse(label_m.Text); int sec = Int32.Parse(label_s.Text); sec++; //如果使用了提示，时间额外加5s if (flag_tips == 1) { sec += 5; flag_tips = 0; } //计算小时 if (min == 60) { hour++; label_h.Text = hour.ToString(); label_m.Text = &quot;0&quot;; if (hour == 100) { timer1.Enabled = false; MessageBox.Show(&quot;计时器已达到上限&quot;, &quot;提示&quot;); return; } } //计算分钟 if (sec &gt;= 60) { min++; label_m.Text = min.ToString(); } //计算秒 sec = sec % 60; label_s.Text = sec.ToString(); } 此设定的缺陷：如果用户在一秒内连续点击多次提示，由于time控件每秒只会触发一次，因此只会增加一次惩罚时间（5s）。由于时间原因，此bug暂未修复，会在以后的学习中完善。 总结在这个项目的设计当中，我查阅了很多资料，也参考了很多资料中设计数独、求解数独的思路，增加了独立完成项目代码的经验。同时本次项目是我第一次使用git进行代码提交，第一次尝试用markdown编写博客，第一次对代码进行单元测试和性能分析，第二次利用Windows窗口应用进行GUI的用户界面设计，在收获许多新的方法和技巧时，也初步了解了一个项目开发的经过，增加了自己的项目经验。 同时由于时间和经验的原因，这个项目的功能还不是很完善，例如time控件对惩罚时长的计算存在一些小缺陷，无法判断数独题目是否有唯一解等，在以后的深入学习中，我会进一步提升自己的能力，来完善他们。 出于商业和实用价值，可以考虑在用户使用“提示”功能时，让他们看30s广告来获取收益（手动狗头）","link":"/2022/03/16/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE-%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F/"},{"title":"编译原理与设计-Lab3-词法分析实验","text":"Windows 10配置Antlr4环境并运行，利用 Antlr4 在 IntelliJ IDEA 生成词法分析器。 实验前的准备工作配置antlr系统环境，可以参考以下教程，其中南京大学那位老师的课程对于antlr入门很合适，初次接触antlr的小伙伴可以参考一下。 Antlr4入门（安装、配置、简单实例） 南京大学一位软件工程老师的antlr4公开课 我根据南大那位老师的公开课写的学习代码 一、实验目的和内容 实验目的熟悉 C 语言的词法规则，了解编译器词法分析器的主要功能和实现技术，掌握典型词法分析器构造方法，设计并实现 C 语言词法分析器； 了解 Flex 工作原理和基本思想，学习使用工具自动生成词法分析器； 掌握编译器从前端到后端各个模块的工作原理，词法分析模块与其他模块之间的交互过程。 实验内容根据 C 语言的词法规则，设计识别 C 语言所有单词类的词法分析器的DFA。并使用 Java，利用ANTLR自动生成词法分析器。词法分析器的输入为 C 语言源程序，输出为属性字流。 实验环境处理器 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz 1.99 GHz机带 RAM 16.0 GB (15.9 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Windows10 二、实验的具体过程和步骤 1. 下载框架并尝试运行下载BIT-MiniCC-master框架，编写简单的测试程序HelloWorld.c，更改config文件以及输入参数，输出的结果如下图所示： 2. Antlr环境配置及规则设计环境配置（1）下载Antler4在下载地址中选择 Tool and Java runtime lib 目录下合适的版本进行下载，我选择的是 antlr-4.8-complete.jar，我的安装路径是C:\\JavaLib\\antlr-4.8-complete.jar。 下载好后在 antlr-4.8-complete.jar 所在目录下新建两个批处理（Batch）文件antlr4.bat和grun.bat，在两个文件中分别写入以下代码： antlr4.bat1java org.antlr.v4.Tool %* grun.bat1java org.antlr.v4.gui.TestRig %* 在 antlr-4.8-complete.jar 所在目录下打开终端命令行，输入antlr4和grun来测试处理文件是否能运行成功。 （2）配置系统环境变量打开（win10）此电脑（右键）属性 -&gt; （右上角）高级系统设置 -&gt; 环境变量。 双击hp的用户变量(U) 中的Path，新建环境变量C:\\JavaLib。 在下方系统变量(S) CLASSPATH 中添加：C:\\JavaLib\\antlr-4.8-complete.jar。 双击系统变量(S) 中的Path，新建环境变量%JAVA_HOME%\\bin，点击右边的上移，把这个环境变量一直上移到最上面，之后新建环境变量，C:\\JavaLib。 以上都配置好后，随便找一个地方打开终端命令行，输入antlr4和grun来测试处理文件是否能运行成功。 规则设计根据实验要求的C11标准编写MyC.g4文件，具体语法规则参考ANTLR官方的C Grammar语法规范文件，大致规则如下： （1）文件名称为MyC.g4，则文件开头必须是grammer MyC;。 （2）Antlr4中对于冲突的解决规则是最前匹配优先、最长匹配优先。 （3）规则的形式为：规则名：分支1 | 分支2 | .. | 分支n ；一段文本匹配规则相当于它匹配其中一个分支，还可用一些类似正则表达式的记号如?、*、+、|和()。 （4）语法规则名以小写字母开始，词法规则名以大写字母开始。 （5）所有对关键字的定义应该排列在标识符ID前面，防止关键字被识别为标识符。部分代码如下：MyC.g412345678910Auto : 'auto'; Break : 'break'; Case : 'case'; Char : 'char'; Const : 'const'; Continue : 'continue'; Default : 'default'; Do : 'do'; Double : 'double'; Else : 'else'; （6）可以用[a-zA-Z]这种形式来表示所有英文字母，后面也可以加上?、*、+等来表示符合正则表达式规则的式子。 （7）一些需要跳过的部分，代码如下：MyC.g4123WS : [ \\t\\r\\n]+ -&gt; skip ; //一个或多个空白符则忽略掉 LCOMMENT : '//' .*? '\\n' -&gt; skip ; //问号表示符合条件的最短的匹配，到第一个换行就停止 MLCOMMENT : '/*' .*? '*/' -&gt; skip ; //.表示所有的 （8）运算符和界限符的定义规则同关键字差不多，部分代码如下：MyC.g4123456LeftParen : '('; RightParen : ')'; LeftBracket : '['; RightBracket : ']'; LeftBrace : '{'; RightBrace : '}'; （9）以fragment 开首的规则可以被词法规则引用以便重用代码，但本身不会生成对解析器可见的词。每定义一个词都要加一个fragment。 3. Antlr4工具使用生成词法分析器编写好MyC.g4文件后，在该文件所在目录下打开命令行，输入 antlr4 MyC.g4 -visitor 生成java文件，然后再输入 javac MyC.g4*.java 对java文件进行编译，生成词法分析器。生成的文件如下图所示： 在命令行输入grun MyC compilationUnit -tokens来测试编写的词法分析器是否成功，输入完命令后再输入一段c语言代码，按Crtl+Z结束。就可以生成对应代码的词法分析结果。 打包词法分析器在MyC.g4所在目录下新建文件夹lib和MyC，将antlr-4.8-complete.jar放入lib文件夹，然后使用IntelliJ IDEA打开整个文件夹。在intelliJ中下载ANTLR v4插件，并找到以下几个文件，在这些文件的开头加上 package MyC; 。 修改完成后，在项目结构和构建-构建工件菜单下，把整个文件打包成jar包。 在BIT-MiniCC-master框架中使用词法分析器把上一步打包好的MyC.jar放入框架的lib文件夹中，在编译器中右键把该jar包添加为库。 编写运行程序运行并调用词法分析器，在src/bit/minisys/minicc目录下，新建MyMiniCompiler.java调用词法分析器，部分代码如下，其中MyScanner是在src/bit/minisys/minicc/scanner目录下新建的类，主要用于将分好的词汇处理写入文件。 src/bit/minisys/minicc/MyMiniCompiler.java12345678910111213141516171819202122232425262728293031323334package bit.minisys.minicc;import MyC.MyCLexer;import MyC.MyCParser;import bit.minisys.minicc.scanner.MyScanner;import org.antlr.v4.runtime.CharStream;import org.antlr.v4.runtime.CharStreams;import org.antlr.v4.runtime.CommonTokenStream;import org.antlr.v4.runtime.tree.ParseTree;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class MyMiniCompiler { public static void main(String[] args)throws IOException { String file = args[0]; System.out.println(&quot;Start to compile ...&quot;); InputStream is = new FileInputStream(file); CharStream input = CharStreams.fromStream(is); MyCLexer lexer = new MyCLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); MyCParser parser = new MyCParser(tokens); ParseTree tree = parser.compilationUnit(); String fName = file.trim(); String temp[] = fName.split(&quot;\\\\\\\\&quot;); String tokenFileName = temp[temp.length - 1] + &quot;.tokens&quot;; MyScanner myScanner = new MyScanner(tokenFileName,tokens); System.out.println(&quot;Compiling completed!&quot;); }} src/bit/minisys/minicc/scanner/MyScanner.java12345678910111213141516171819package bit.minisys.minicc.scanner;import org.antlr.v4.runtime.CommonTokenStream;import java.io.File;import java.io.FileWriter;import java.io.IOException;public class MyScanner { public MyScanner(String tokenFileName,CommonTokenStream tokens) throws IOException { System.out.println(&quot;Scanning...&quot;); FileWriter fileWriter = new FileWriter(new File(tokenFileName)); for(int i = 0; i &lt; tokens.getNumberOfOnChannelTokens(); i++){ fileWriter.write(tokens.get(i).toString()); fileWriter.write(&quot;\\n&quot;); } fileWriter.close(); }} 运行程序右键MyMiniCompiler修改运行配置，将输入参数改为测试文件的路径test/scan_test/1_scanner_test.c，右键运行MyMiniCompiler.main()，可以看到在根目录下生成了文件1_scanner_test.c.tokens。 三、运行效果截图 运行后生成的文件在红框处，文件部分截图如图所示。 四、实验心得体会 在本次实验中，我新接触到了可以自动生成词法分析器的Antlr4，进一步了解了C语言中词法的结构，加深了对C语言词法法规的理解，初步了解了到词法分析模块与其他模块之间的交互过程，更深入的体会到了编译原理的魅力。","link":"/2022/03/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab3-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/"},{"title":"编译原理与设计-Lab4-文法设计与验证实验","text":"本实验主要为阅读 C 语言规范草稿，了解语言规范化定义应包括的具体内容。选定 C 语言子集，并使用 BNF 表示方法文法进行描述，要求至少包括表达式、赋值语句、分支语句和循环语句。 一、实验目的和内容 实验目的本次实验的主要目的是了解程序设计语言的演化过程和相关标准的制定过程，深入理解与编译实现有关的形式语言理论，熟练掌握文法及其相关的概念，并能够使用文法对给定的语言进行描述，为后面的词法分析和语法分析做准备。 实验内容阅读附件提供的 C 语言和 Java 语言的规范草稿，了解语言规范化定义应包括的具体内容。 选定 C 语言子集，并使用 BNF 表示方法文法进行描述，要求至少包括表达式、赋值语句、分支语句和循环语句。 以上语言定义首先要给出所使用的字母表，在此基础上使用 2 型文法描述语法规则。 实验环境处理器 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz 1.99 GHz机带 RAM 16.0 GB (15.9 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Windows10 二、对语言规范的理解 语言标准规范是每个语言的说明文档，定义了语言的字符集、词法规则、语法规则和语义规则，也包括了对程序结构、编译过程、标准库程序以及语言实现等各方面的内容。只有明确统一了一个语言的规范，这个语言才能更好的被别人理解、使用。 在C语言的标准规范中不仅仅针对语言本身，更明确了C语言源代码到转译为可执行程序的每一步，以及每一步里的数据结构，转换方法、存储进行了严格说明。C语言规范保证了语言的严谨性，尽力消除歧义。 三、C语言文法子集描述 1. 字母表字母表123Nondigit : [a-zA-Z_] ; //非数字Digit : [0-9] ; //数字 Punctuator : !&quot;#%&amp;'()*+,-./: ;&lt;=&gt;?[\\]^_{|}~ ; //符号 2. 语法规则语法分析的终结符一共有5种：关键字 keyword /标识符 Identifier /字符串字面量 StringLiteral /常量 Constant /分隔符及运算符 punctuator，即词法分析得到的5种token。statement定义了多种语句类型。 123456789// 语句类型 statement : labeled_statement | compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement ; 表达式表达式包含多种，在法则中可以利用多级调用来说明运算符的优先性。 表达式123456expression : assignment_expression (',' assignment_expression)* ; constant_expression : conditional_expression ; 主要表达式，包括括号、字符串等几种常见的表达式1234567primary_expression : Identifier | Constant | StringLiteral+ | '(' expression ')' | generic_selection ; 一元运算表达式1234567unary_expression : | '++' unary_expression | '--' unary_expression | ('&amp;' | '*' | '+' | '-' | '~' | '!') cast_expression | 'sizeof' '(' typeName ')' ; 类型转换表达式1234cast_expression : unary_expression | '(' typeName ')' cast_expression ; 加减乘除余运算表达式123456789multiplicative_expression : cast_expression | cast_expression ('*'|'/'|'%') multiplicative_expression ; additive_expression : multiplicative_expression | multiplicative_expression ('+'|'-') additive_expression ; 位移、关系比较表达式1234567891011121314shift_expression : additive_expression | additive_expression ('&lt;&lt;'|'&gt;&gt;') shift_expression ; relational_expression : shift_expression | shift_expression ('&lt;'|'&gt;'|'&lt;='|'&gt;=') relational_expression ; equality_expression : relational_expression | relational_expression ('=='| '!=') equality_expression ; 位运算、逻辑运算表达式1234567891011121314151617181920212223242526272829and_expression : equality_expression | equality_expression '&amp;' and_expression ; Exclusive_or_expression : and_expression | and_expression '^' exclusive_or_expression ; Inclusive_or_expression : exclusive_or_expression | exclusive_or_expression '|' inclusive_or_expression ; Logical_and_expression : inclusive_or_expression | inclusive_or_expression '&amp;&amp;' logical_and_expression ; Logical_or_expression : logical_and_expression | logical_and_expression '||' logical_or_expression ; conditional_expression : logical_or_expression | logical_or_expression '?' expression ':' conditional_expression ; 赋值语句赋值语句也是表达式的一种，主要是条件表达式或者一元表达式+赋值运算符+赋值语句，其中条件表达式使用多元运算符也可以对语句进行赋值。 123456789//赋值语句 assignment_expression : conditional_expression | unary_expression assignment_operator assignment_expression ; //赋值运算符 assignment_operator : '=' | '*=' | '/=' | '%=' | '+=' | '=' | '&lt;&lt;=' | '&gt;&gt;=' | '&amp;=' | '^=' | '|=' ; 分支语句分支语句有三种形式，分别是if、if-else、switch。 关键字if、switch开头，括号里面加判断条件expression，然后跟执行的结构体statement，在if语句中后面还可以跟关键字else+执行的结构体statement。 123456//if和switch分支语句 selection_statement : 'if' '(' expression ')' | 'if' '(' expression ')' statement 'else' statement | 'switch' '(' expression ')' statement ; 循环语句循环语句有四种形式，分别是while、do-while、for(;;)、for(;)。 分别是关键字while、do、for开头，后面括号里加判断条件expression，再跟执行的结构体statement。 1234567//while和for循环语句 iteration_statement : 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement ; 四、运行效果截图 表达式 赋值语句 分支语句 循环语句 HelloWorld程序 五、推导过程心得体会 在本次实验中，我进一步理解了C语言中语法的结构，阅读了C语言的规范文件，认识并理解了真正的语法树，对C语言的产生过程和编译过程有了更深一步的认识，加深了对C语言文法法规的理解，掌握了文法的概念。 C语言的文法法规设计是及其严谨的，从C语言标准中选择可以正常运行的子集也需要极其小心的取舍，并对选取的子集加以改进。C语言标准在最初的设计时，每一条语法设计之间的关系都十分紧密，形成了一个紧密的链条，缺少任何一个都可能使程序无法运行。在对C语言标准进行取舍和进行文法设计的同时，我也了解了到文法规则每一个模块与其他模块之间的交互过程，更深入的体会到了编译原理的魅力。","link":"/2022/03/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab4-%E6%96%87%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/"},{"title":"计算机网络实验 Experiment 3.1 PPP配置与分析","text":"计算机网络实验指导（郑宏 宿红毅） 实验3.1 PPP 配置与分析 实验目的1．掌握 PPP 特点、工作过程和基本配置方法。2．掌握 PPP PAP 鉴别的特点配置方法。3．掌握 PPP CHAP 鉴别的特点和配置方法。4．掌握 PPP IP 地址协商的配置方法。 实验装置1．华为 eNSP 软件。2．ping。3．Wireshark。 安装配置ensp参考资料： 华为模拟器ENSP下载与安装教程 华为网络篇 eNSP的安装与使用-01 第一个链接主要讲如何下载配置，第二个链接包含一些基础的使用说明。需要注意的是，安装ensp前还需要下载三个软件，分别是VirtualBox、WinPcap、wireshark，其中VirtualBox必须是5.2.x版本，我本机带有6.x版本，但是启动ensp时显示不适配。 在下载Winpacp的时候，如果你的电脑之前下载过npacp，在安装winpacp时会可能报错，提示这台机器上已有winpacp。解决方法是把C:\\Windows\\SysWOW64目录下的Packet.dll和wpcap.dll重命名为Packet.dll.old和wpcap.dll.old。 实验3.1.1：PPP基本配置这个实验非常简单，基本没有会出错的地方，按照实验书上的步骤一步步来即可。 表格中的串口号可以右键路由器，在设置里查看，二者的串口号分别为2000和2001。 实验3.1.2：PAP鉴别配置具体实验过程也很简单，基本不会出错。以下问题的答案为我本人查找到的资料总结和自己的思考，并非标准答案，仅供参考。 Q: PAP两次握手报文分别是什么？ A: 第一次报文是主认证方发送用户名和密码，Request报文。 第二次报文是接收方接收到了消息后查看信息中的用户名，然后对应自己数据库中的用户名和密码进行认证，反馈认证结果，ACK或NAK报文。 实验3.1.3：CHAP鉴别配置具体实验过程也很简单，基本不会出错。以下问题的答案为我本人查找到的资料总结和自己的思考，并非标准答案，仅供参考。 值得注意的是，CHAP进行抓包时，抓包到的用户名和密码中，密码是进行加密过的密文，有别于PAP中的明文。 Q: CHAP三次握手报文分别是什么？ A: 第一次报文是发送随即报文和本地用户名，Challenge报文。 第二次报文是接收方接收到了消息后查看信息中的用户名，然后对应自己数据库中的用户名和密码进行认证，并用md5算法对随即报文进行加密，把加密结果和本地用户名一起发送给主认证方。Response报文。 第三次报文是主认证方接收到信息后，查看信息中的用户名和密码，并与自己的数据库进行对比认证。Success报文。 实验3.1.4：IP地址协商具体实验过程也很简单，基本不会出错。以下问题的答案为我本人查找到的资料总结和自己的思考，并非标准答案，仅供参考。 Q: 分析Wireshark抓取到的PPP数据包。PPP使用哪个协议、哪种报文为对端分配IP地址？请将该报文信息的截图粘贴在实验报告中。 A: 认证协议：IPCP 报文：Configuration Request 认证协议可以通过Protocol查看。 结合Wireshark抓取的PPP通信，利用状态图，说明PPP协议的工作过程。","link":"/2022/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Experiment-3-1-PPP%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%88%86%E6%9E%90/"},{"title":"刷题-C语言的知识增加了","text":"本文记录一个基础没好好学的菜鸡在刷题过程中新学到的函数、语法等知识点，本文将持续更新……刷题网站： 力扣 Leetcode 牛客 华为机试牛客试题 C/C++bitsetbitset定义和初始化1234bitset&lt;n&gt; b; //b有n位，每位都为0bitset&lt;n&gt; b(u); //b是unsigned long型u的一个副本bitset&lt;n&gt; b(s); //b是string对象s中含有的位串的副本bitset&lt;n&gt; b(s, pos, n); //b是s中从位置pos开始的n个位的副本 bitset基本运算12345678910111213141516171819//bitset支持所有位运算bitset&lt;23&gt;bita(string(&quot;11101001&quot;));bitset&lt;23&gt;bitb(string(&quot;11101000&quot;));cout&lt;&lt;(bita^bitb)&lt;&lt;endl;//输出00000000000000000000001 bitset&lt;23&gt;bita(string(&quot;11101001&quot;));bitset&lt;23&gt;bitb(string(&quot;11101000&quot;));cout&lt;&lt;(bita|bitb)&lt;&lt;endl;//输出00000000000000011101001bitset&lt;23&gt;bita(string(&quot;11101001&quot;));bitset&lt;23&gt;bitb(string(&quot;11101000&quot;));cout&lt;&lt;(bita&amp;bitb)&lt;&lt;endl;//输出00000000000000011101000bitset&lt;23&gt;bit(string(&quot;11101001&quot;));cout&lt;&lt;(bit&lt;&lt;5)&lt;&lt;endl;//输出00000000001110100100000bitset&lt;23&gt;bit(string(&quot;11101001&quot;));cout&lt;&lt;(bit&gt;&gt;5)&lt;&lt;endl;//输出00000000000000000000111 bitset常用函数123456789101112131415//对于一个叫做bit的bitset：bit.size() //返回大小（位数）bit.count() //返回1的个数bit.any() //返回是否有1bit.none() //返回是否没有1bit.set() //全都变成1bit.set(p) //将第p + 1位变成1（bitset是从第0位开始的！） bit.set(p, x) //将第p + 1位变成xbit.reset() //全都变成0bit.reset(p) //将第p + 1位变成0bit.flip() //全都取反bit.flip(p) //将第p + 1位取反bit.to_ulong() //返回它转换为unsigned long的结果，如果超出范围则报错bit.to_ullong() //返回它转换为unsigned long long的结果，如果超出范围则报错bit.to_string() //返回它转换为string的结果 题目实例 输入描述： 输入一个整数（int类型） 输出描述： 这个数转换成2进制后，输出1的个数 示例： 输入：5 输出：2 123456789#include&lt;bitset&gt;#include&lt;iostream&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; bitset&lt;32&gt; b(n); cout&lt;&lt;b.count();}","link":"/2022/04/06/%E5%88%B7%E9%A2%98-C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%9F%A5%E8%AF%86%E5%A2%9E%E5%8A%A0%E4%BA%86/"},{"title":"我的微信小程序学习笔记","text":"记录我从零开始的微信小程序学习，本文将持续更新……使用工具：微信开发者工具。 参考资料： b站的一个微信小程序开发教程这个教程太详细了，一个知识点反复讲三四遍，感觉是给非科班的小白讲的，计算机科班出身的可以跳着看+快进。 微信官方文档-小程序 微信公众平台 微信小程序篇—如何使用iconfont彩色图标—Symbol类型 一、贼基础的基础 1、框架基础介绍 app.json是全局配置，在&quot;pages&quot;中可以通过代码直接新建文件夹。 app.js是开启微信小程序的启动程序。 app.wxss是全局样式，在每个窗口的文件夹里可以设置各自的样式。 ctrl+/是加注释的快捷键。 2、组件viewview类似于div，就这么简单。scroll-view可以给这个小窗口添加滚轮。 .wxml123456&lt;!-- scroll-y指按y轴纵向滚动，纵向滚动必须在wxss中设置强制性的高度 --&gt;&lt;scroll-view class=&quot;container1&quot; scroll-y&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt;&lt;/scroll-view&gt; .wxss123456789101112131415161718192021222324252627/*引用xx类中的xx组件*/.container1 view{ width: 100px; height: 100px; /*让文本在横线纵向都居中*/ text-align: center; line-height: 100px;}/*类container1中的第一个view*/.container1 view:nth-child(1){ background-color: lightgreen;}.container1 view:nth-child(2){ background-color: lightskyblue;}.container1 view:nth-child(3){ background-color: lightcoral;}.container1 { display: flex; justify-content: space-around; border: 1px solid red; width: 100px; height: 120px;} swiper利用swiper和swiper-item实现轮播图。swiper组件常用属性： .wxml123456789101112131415&lt;!--轮播图的结构--&gt;&lt;swiper class=&quot;swiper-container&quot; indicator-dots=&quot;true&quot; indicator-color=&quot;white&quot;&gt; &lt;!-- 第一个轮播图 --&gt; &lt;swiper-item&gt; &lt;view class = &quot;item&quot;&gt;A&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view class = &quot;item&quot;&gt;B&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view class = &quot;item&quot;&gt;C&lt;/view&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; .wxss123456789101112131415161718192021/* 轮播图的样式 */.swiper-container{ height: 150px;}.item{ height: 100%; line-height: 150px; text-align: center;}/* .item前面要加空格 */swiper-item:nth-child(1) .item{ background-color: lightgreen;}swiper-item:nth-child(2) .item{ background-color: lightblue;}swiper-item:nth-child(3) .item{ background-color: lightpink;} 获取轮播图的数据： home.js1234567891011121314151617181920212223242526272829303132Page({ /** * 页面的初始数据 */ data: { // 存放轮播图数据的列表 swiperList: [] }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { this.getSwiperList() }, // 获取轮播图数据 getSwiperList(){ wx.request({ url: 'https://www.escook.cn/slides', method: 'GET', success: (res) =&gt; { console.log(res) this.setData({ swiperList: res.data }) } }) }, ···)} test小程序中只有test组件支持长按选中文本，view等不支持。 .wxml12345678&lt;!-- test 和 rich-text --&gt;&lt;view&gt; &lt;text&gt;手机号支持长按选中效果&lt;/text&gt; &lt;text selectable=&quot;true&quot;&gt;18888888888&lt;/text&gt;&lt;/view&gt;&lt;!-- rich-text可以通过nodes属性把文字渲染成UI效果 --&gt;&lt;rich-text nodes=&quot;&lt;h1 style='color : red;'&gt;标题&lt;/h1&gt;&quot;&gt;&lt;/rich-text&gt; button小程序中的按钮组件功能比html中的丰富，可以通过open-type属性调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）。 .wxml12345&lt;button&gt;普通按钮&lt;/button&gt;&lt;button type=&quot;primary&quot;&gt;主色调按钮&lt;/button&gt;&lt;button type=&quot;warn&quot;&gt;警告按钮&lt;/button&gt;&lt;button size=&quot;mini&quot;&gt;小按钮&lt;/button&gt;&lt;button plain=&quot;true&quot; size=&quot;mini&quot;&gt;镂空按钮&lt;/button&gt; imageimage组件默认宽度300px，高度200px。image组件中可以通过mode属性来指定图片的裁剪和缩放。常用的mode属性值如下。 .wxml1&lt;image src=&quot;/images/1.jpg&quot; mode=&quot;aspecFill&quot;&gt;&lt;/image&gt; 3、API小程序官方把小程序API大致分为如下三类： 事件监听API 特点：以on开头，用来监听某些事件的触发。 举例：wx.onWindowResize(function callback)监听窗口尺寸的变化。 同步API 特点1：以Sync结尾的API都是同步API。 特点2：同步API的执行结果可以通过函数返回值直接获取，如果执行错误会异常抛出。 举例：wx.setStorageSync('key', 'value')向本地存储中写入内容。 异步API 特点：需要通过success、fail、complete接收调用的结果。 举例：wx.request()发起网络数据请求，通过success回调函数接收数据。 4、WXML模板语法数据绑定在Page中的data里定义数据，wxml中使用数据。可以在 调试器-AppData 中查看生成的数据。 .js123456789101112131415data: { info: 'hello world', imgSrc: 'http://www.itheima.com/images/logo.png', randomNum1: Math.random() * 10, randomNum2: Math.random().toFixed(2), //生成两位小数随机数 count: 0, msg: '你好', type: 1, arr1: ['苹果','华为','小米'], userList: [ {id: 1, name: '小红'}, {id: 2, name: '小黄'}, {id: 3, name: '小白'} ],}, .wxml1234&lt;view&gt;{{info}}&lt;/view&gt;&lt;image src=&quot;{{imgSrc}}&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;&lt;view&gt;{{randomNum1 &gt;= 5 ? '输出对' : '输出不对'}}&lt;/view&gt;&lt;view&gt;{{randomNum2 * 100}}&lt;/view&gt; 事件绑定小程序中常用的事件如下： bindtapbindtap可以为组件绑定触摸事件，需要注意的是，小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传参，要用data-*传参，其中*是参数的名字，获取参数使用e.target.dataset.参数名字。 .js1234567891011121314151617181920// 定义按钮的事件处理函数bthTapHandler(e){ console.log(e) //打印事件e，可以在调试器的console中看到},// +1按钮的点击事件处理函数CountChange(e){ this.setData({ count: this.data.count + 1 })},// 传参+2btnTap2(e){ console.log(e), console.log(e.target.dataset.info), this.setData({ count: this.data.count + e.target.dataset.info })}, .wxml1234&lt;button type=&quot;primary&quot; bindtap=&quot;bthTapHandler&quot;&gt;按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;CountChange&quot;&gt;+1&lt;/button&gt;&lt;!-- 传递数字是{{}}，直接&quot;2&quot;是字符，传参不能用btnTap2(2) --&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;btnTap2&quot; data-info=&quot;{{2}}&quot;&gt;+2&lt;/button&gt; bindinput.js12345678// input输入框的事件处理函数inputHandler(e){ // 拿到文本框中输入的值 console.log(e.detail.value) this.setData({ msg: e.detail.value })}, .wxml1&lt;input value=&quot;{{msg}}&quot; bindinput=&quot;inputHandler&quot;&gt;&lt;/input&gt; .wxss123456input { border: 1px solid #eee; margin: 5px; padding: 5px; border-radius: 3px; /* 圆角矩形 */} 条件渲染wx:if和hidden的对比： 运行方式不同 wx:if：以动态创建和移除元素的方式来控制元素的展示与隐藏。 hidden: 本质是切换样式（display:none/block;） 使用建议 wx:if: 控制条件复杂。 hidden: 频繁切换。频繁切换时如果使用if可能大量消耗内存。 .wxml1234567891011&lt;!-- 条件渲染 --&gt;&lt;view wx:if=&quot;{{type === 1}}&quot;&gt;男&lt;/view&gt;&lt;view wx:elif=&quot;{{type === 2}}&quot;&gt;女&lt;/view&gt;&lt;view wx:else&gt;保密&lt;/view&gt;&lt;!-- block标签只起到包裹作用，不会被渲染成任何组件 --&gt;&lt;block wx:if=&quot;{{true}}&quot;&gt;&lt;!-- hidden表示是否隐藏组件 --&gt; &lt;view hidden=&quot;{{true}}&quot;&gt; view 1&lt;/view&gt; &lt;view&gt; view 2&lt;/view&gt;&lt;/block&gt; 列表渲染.wxml1234567&lt;!-- 列表渲染 --&gt;&lt;view wx:for=&quot;{{arr1}}&quot; wx:key=&quot;index&quot;&gt; 索引是： {{index}}, item项是：{{item}}&lt;/view&gt;&lt;!-- 使用 wx:for 最好都加上key，key中的值不用{{}}，可以提高循环效率 --&gt;&lt;view wx:for=&quot;{{userList}}&quot; wx:key=&quot;id&quot; class=&quot;username&quot;&gt;{{item.name}}&lt;/view&gt; 5、WXSS模板样式使用@import导入样式。局部样式会覆盖全局样式app.wxss，需要注意的是局部样式的权重大于等于全局样式时才会覆盖（鼠标停留在.wxss的函数上可以查看当前函数样式的权重）。 .wxss1234/* 整体根目录下的common.wxss */.username { color: red;} wxss123456789/* pages/list/list.wxss */@import &quot;/common/common.wxss&quot;;input { border: 1px solid #eee; margin: 5px; padding: 5px; border-radius: 3px; /* 圆角矩形 */} 6、全局配置全局配置文件是app.json。 pages: 记录小程序所有页面存放路径。 window: 全局设置小程序窗口外观，配置导航栏区域和背景区域（默认不可见，下拉才可见）。 tabBar: 设置小程序底部的 tabBar 样式。 style: 是否启用新版的组件样式（v1太丑了）。 windowwindow节点常用配置项如下（另外一提.json居然不支持注释）： app.json12345678910111213141516171819{ &quot;pages&quot;: [ &quot;pages/list/list&quot;, &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;: { &quot;backgroundTextStyle&quot;: &quot;dark&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#eee&quot;, &quot;navigationBarTitleText&quot;: &quot;这是小程序最上方的标题&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;enablePullDownRefresh&quot;: true, &quot;backgroundColor&quot;: &quot;#efefef&quot;, &quot;onReachBottomDistance&quot;: 50 }, &quot;style&quot;: &quot;v2&quot;, &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;, &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;} tabBartabBar分为顶部tabBar和底部tabBar，只能配置最少2个、最多5个tab页签。当渲染顶部tabBar时不显示对应的icon，只显示文本。 每个tab项的配置选项，tab页签对应的页面必须放赞pages的前面声明。 app.json12345678910111213141516&quot;tabBar&quot;: { &quot;list&quot;: [ { &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;index&quot;, &quot;iconPath&quot;: &quot;/images/icon.jpg&quot;, &quot;selectedIconPath&quot;: &quot;/images/icon_a.jpg&quot; }, { &quot;pagePath&quot;: &quot;pages/list/list&quot;, &quot;text&quot;: &quot;list&quot;, &quot;iconPath&quot;: &quot;/images/icon.jpg&quot;, &quot;selectedIconPath&quot;: &quot;/images/icon_a.jpg&quot; } ]}, 各个小页面配置的常用配置项： message.json1234567{ &quot;usingComponents&quot;: {}, &quot;navigationBarBackgroundColor&quot;: &quot;#ff0000&quot;, &quot;navigationBarTitleText&quot;: &quot;消息页面&quot;, &quot;backgroundColor&quot;: &quot;#ff0000&quot;, &quot;enablePullDownRefresh&quot;: false} 7、网络数据请求小程序官方对数据接口的请求做出了如下要求： 只能请求HTTPS类型的接口。 必须把接口的域名添加到信任列表中（小程序开发者工具-右上角详情-项目配置-request合法域名 / 小程序管理后台-开发管理-开发设置-服务器域名）。 域名只支持https协议。 域名不能使用IP或者localhost。 域名必须经过ICP备案。 服务器域名一个月最多申请修改5次。 发送GET请求home.js1234567891011121314// 发起GET数据请求getInfo(){ wx.request({ url: 'https://www.escook.cn/api/get', // 请求的接口地址，必须基于 https 协议 method: 'GET', // 请求的方式 data: { // 发送到服务器的数据 name: 'zs', age: 20 }, success: (res) =&gt; ( // 请求成功之后的回调函数 console.log(res) ) })}, 发起POST请求home.js1234567891011121314// 发起POST请求postInfo(){ wx.request({ url: 'https://www.escook.cn/api/post', // 请求的接口地址，必须基于 https 协议 method: 'POST', // 请求的方式 data: { // 发送到服务器的数据 name: 'ls', age: 33 }, success: (res) =&gt; ( // 请求成功之后的回调函数 console.log(res) ) })}, 在页面刚加载时就请求数据利用框架中的onLoad函数。 home.js1234567/** * 生命周期函数--监听页面加载 */onLoad: function (options) { this.getInfo() this.postInfo()}, 二、视图与逻辑1、页面导航小程序中实现页面导航有两种方式： 声明式导航 在页面上声明导航组件 点击实现页面跳转 编程式导航 调用小程序的导航API实现页面跳转 声明式导航（1）导航到tabBar页面使用导航组件跳转到指定的tabBar页面时，需要指定url（必须以/开头）和open-type属性（必须为switchTab）。 home.wxml1&lt;navigator url=&quot;/pages/message/message&quot; open-type=&quot;switchTab&quot;&gt;导航到消息页面&lt;/navigator&gt; （2）导航到非tabBar页面使用导航组件跳转到指定的非tabBar页面时，需要指定url（必须以/开头），open-type属性（必须为navigate）可省略。 home.wxml12&lt;navigator url=&quot;/pages/info/info&quot; open-type=&quot;navigate&quot;&gt;导航到info页面&lt;/navigator&gt;&lt;navigator url=&quot;/pages/info/info&quot;&gt;导航到info页面&lt;/navigator&gt; （3）后退导航后退到上一页或多级页面时，需要指定open-type属性（必须为navigateBack），delta属性（值必须是数字，表示要后退的层级，默认为1）可省略。 info.wxml12&lt;navigator open-type=&quot;navigateBack&quot; delta=&quot;1&quot;&gt;后退1个页面&lt;/navigator&gt;&lt;navigator open-type=&quot;navigateBack&quot;&gt;后退1个页面&lt;/navigator&gt; 编程式导航（1）导航到tabBar页面","link":"/2022/04/01/%E6%88%91%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"编译原理与设计","slug":"编译原理与设计","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Hexo &amp; Icarus","slug":"Hexo-Icarus","link":"/tags/Hexo-Icarus/"},{"name":"打工小妙招","slug":"打工小妙招","link":"/tags/%E6%89%93%E5%B7%A5%E5%B0%8F%E5%A6%99%E6%8B%9B/"},{"name":"软件工程基础","slug":"软件工程基础","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"C&#x2F;C++&#x2F;C#","slug":"C-C-C","link":"/tags/C-C-C/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"categories":[{"name":"Guide","slug":"Guide","link":"/categories/Guide/"},{"name":"Experimental report","slug":"Experimental-report","link":"/categories/Experimental-report/"},{"name":"Life &amp; Hello-world","slug":"Life-Hello-world","link":"/categories/Life-Hello-world/"},{"name":"Hello-world","slug":"Life-Hello-world/Hello-world","link":"/categories/Life-Hello-world/Hello-world/"},{"name":"Study study!","slug":"Study-study","link":"/categories/Study-study/"},{"name":"Project","slug":"Project","link":"/categories/Project/"}]}