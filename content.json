{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/08/hello-world/"},{"title":"Windows10 和 VSCode 上Haskell的安装与环境搭建","text":"在Windows10 和 VSCode 上安装搭建Haskell环境 参考资料：【VS Code】Windows10下VS Code配置Haskell语言环境在整体的环境安装配置过程中，多处涉及到github链接和需要翻墙的链接，部分校园网可能会链接失败，可以尝试手机热点。 1. 下载安装Stack打开Stack官方文档，选择Windows 64-bit Installer进行下载，双击下载下来的exe文件进行安装，可以自定义C盘路径，但是要以管理员身份运行。 Windows 64-bit Installer 安装步骤1 安装过程中，还会自动将Stack添加到用户环境变量 PATH 中，同时会设置 STACK_ROOT=C:\\sr（安装程序的默认选项，记住这个路径，后面要考），安装完成后，可以在cmd终端输入命令“stack –help”来检验安装是否成功。 安装步骤2 2. 安装GHC（麻烦bug多）Stack可以用于管理Haskell编译器GHC和Haskell库，因此使用Stack安装GHC。 由于Haskell的生态和版本支持不是很好，如果你直接安装而不固定版本号，软件包的安装就容易引起冲突，导致各种依赖项间的不兼容。访问这个网站，查看Haskell最新的LTS，然后锁定在这个LTS上，此处我选择的是最新的LTS 18.27。 Stackage 一些辅助理解的概念（和配置环境关系不大，你可以不看）： Hackage是Haskell社区的开源软件包仓库 The Haskell Package Repository ，可以发布库和程序，或者使用Cabal-install这样的软件包管理器下载和安装软件包。 Stackage是 Stable Haskell package sets 的缩写，即稳定一致的Haskell包集合。它是一个Haskell软件包子集的发行版，来自Hackage并和它一同被社区构建起来。Stackage存在的意义在于，它提供了兼容一致且稳定的Haskell包集，每个包都选择了一个特定版本以满足软件包集合的自洽性，从而解决包版本的冲突问题、顺利构建和运行项目。 Stackage提供和维护了一堆不同的大版本，每个大版本都对应一个兼容一致稳定的Haskell包集，或者说是一个LTS Long Term Service ，被社区长期支持。我们选定了一个LTS之后，在下载安装时只可能发生某个包不存在的情况，就算出现冲突也能通过Stack来轻松解决，不会埋下一大堆“地雷”。 2.1 配置stack在cmd终端执行stack install，会发现下载经常失败。 1(ConnectionFailure user error (Network.Socket.gai_strerror not supported: 11004)) 这是因为下载过程中的一个网址需要翻墙才能访问，在不翻墙的情况下，需要进行换源才可以下载成功。 参考资料：关于stack换源的问题 其中提到了两个清华源的网址，“可以同时使用 TUNA 的 Stackage 源 + Hackage 源来解决”，分别是stackage 镜像使用帮助和hackage 镜像使用帮助。 在stackage 镜像使用帮助中提到“本镜像推荐与 TUNA 的 Hackage 镜像配合使用”，因此两个镜像源都需要添加。 2.2 换源：在终端输入stack --version查看stack版本，然后在上述两个源链接中分别找到对应版本的源进行更换，我的stack版本是2.7.3，在这里说明我的换源过程： （1）下载 stackage 镜像中提示的文件： stackage 镜像 下载图片下方蓝色链接的global-hints.yaml文件，在系统中找到对应的文件夹，不同下载路径对应的文件夹不同，此处的路径就是上文提及的记下来要考的路径： 默认路径下载时，直接在c盘路径输入%APPDATA%，然后回车就可以打开对应文件夹。 %APPDATA% 我下载的时候更改了默认路径，所以要修改的配置文件是%STACK_ROOT%\\config.yaml，配置文件对应的路径是上面记住要考的哪个C:\\sr\\config.yaml。 （2）更换源现在你已经找到了对应的目录，在此目录下的pantry文件夹内放入刚刚下载好的global-hints.yaml文件，并更改 stack（默认路径）或sr（我更改的路径）目录下的config.yaml，在此文件中增添两个镜像源中对应版本的代码，我的版本是2.7.3： stack hackage 即在config.yaml中增加以下代码： 123456789101112131415161718192021222324package-indices: - download-prefix: http://mirrors.tuna.tsinghua.edu.cn/hackage/ hackage-security: keyids: - 0a5c7ea47cd1b15f01f5f51a33adda7e655bc0f0b0615baa8e271f4c3351e21d - 1ea9ba32c526d1cc91ab5e5bd364ec5e9e8cb67179a471872f6e26f0ae773d42 - 280b10153a522681163658cb49f632cde3f38d768b736ddbc901d99a1a772833 - 2a96b1889dc221c17296fcc2bb34b908ca9734376f0f361660200935916ef201 - 2c6c3627bd6c982990239487f1abd02e08a02e6cf16edb105a8012d444d870c3 - 51f0161b906011b52c6613376b1ae937670da69322113a246a09f807c62f6921 - 772e9f4c7db33d251d5c6e357199c819e569d130857dc225549b40845ff0890d - aa315286e6ad281ad61182235533c41e806e5a787e0b6d1e7eef3f09d137d2e9 - fe331502606802feac15e514d9b9ea83fee8b6ffef71335479a2e68d84adc6b0 key-threshold: 3 # number of keys required # ignore expiration date, see https://github.com/commercialhaskell/stack/pull/4614 ignore-expiry: nosetup-info-locations: [&quot;http://mirrors.tuna.tsinghua.edu.cn/stackage/stack-setup.yaml&quot;]urls: latest-snapshot: http://mirrors.tuna.tsinghua.edu.cn/stackage/snapshots.jsonsnapshot-location-base: https://mirrors.tuna.tsinghua.edu.cn/stackage/stackage-snapshots/ （3）配置GHC回到终端，运行命令stack --resolver lts-18.27 setup下载lts，成功代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253C:\\Users\\hp&gt;stack --resolver lts-18.27 setupWarning: http://mirrors.tuna.tsinghua.edu.cn/stackage/stack-setup.yaml: Unrecognized field in GHCDownloadInfo: versionPreparing to install GHC to an isolated location.This will not interfere with any system-level installation.Already downloaded.Downloaded 7z.dll.Downloaded 7z.exe.Decompressing ghc-8.10.7.tar.xz...7-Zip 9.20 Copyright (c) 1999-2010 Igor Pavlov 2010-11-18Processing archive: C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.10.7.tar.xzExtracting ghc-8.10.7.tarEverything is OkSize: 2768711680Compressed: 434126144Extracting ghc-8.10.7.tar...Extracted total of 10342 files from ghc-8.10.7.tarGHC installed to C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.10.7\\Downloaded msys2-20210604.Already downloaded.Already downloaded.Decompressing msys2-20210604.tar.xz...7-Zip 9.20 Copyright (c) 1999-2010 Igor Pavlov 2010-11-18Processing archive: C:\\Users\\hp\\AppData\\Local\\Programs\\stack\\x86_64-windows\\msys2-20210604.tar.xzExtracting msys2-20210604.tarEverything is OkSize: 390021120Compressed: 99822772Extracting msys2-20210604.tar...Extracted total of 17688 files from msys2-20210604.tarCopying skeleton files.These files are for the users to personalise their msys2 experience.They will never be overwritten nor automatically updated.'./.bashrc' -&gt; '/home/hp/.bashrc''./.bash_logout' -&gt; '/home/hp/.bash_logout''./.bash_profile' -&gt; '/home/hp/.bash_profile''./.inputrc' -&gt; '/home/hp/.inputrc''./.profile' -&gt; '/home/hp/.profile'\u001b[0mstack will use a sandboxed GHC it installed\u001b[0m\u001b[0mFor more information on paths, see 'stack path' and 'stack exec env'\u001b[0m\u001b[0mTo use this GHC and packages outside of a project, consider using:\u001b[0m\u001b[0mstack ghc, stack ghci, stack runghc, or stack exec\u001b[0m 测试一下GHC是否安装成功： 1234567C:\\Users\\hp&gt;stack exec -- ghc --versionThe Glorious Glasgow Haskell Compilation System, version 8.10.7C:\\Users\\hp&gt;stack exec -- ghciGHCi, version 8.10.7: https://www.haskell.org/ghc/ :? for helpPrelude&gt; :quitLeaving GHCi. 到此，我们已经有了一个可用的Stack和GHC（芜湖撒花）。 3.配置VSCode3.1 安装插件由于VSCode中的一部分插件版本过老，和新版本的GHC不匹配，因此下载旧版本的GHC做备用，一般来说LTS9不会出现冲突。 在终端执行以下命令进行安装，并检测安装是否成功： 12stack --resolver lts-9.21 setupstack --compiler ghc-8.0.2 exec -- ghc --version 配置完成后，在VSCode扩展中安装以下插件： Haskell ghc-mod Haskell-linter Haskell Syntax Highlighting Haskelly Haskell Code Runner 然后在终端配置插件，分别执行以下命令（这一步所需时间较长，如果一次没配置完，第二次重新打开终端时，需要重新输入chcp 65001） 1234chcp 65001stack --resolver lts-9.21 install ghc-modstack --resolver lts-9.21 install hlintstack --resolver lts-9.21 install intero QuickCheck stack-run 以上这些安装完成后，终端显示如下，不用管那个Warning，但是要记住他那个路径 C:\\Users\\hp\\AppData\\Roaming\\local\\bin，Stack安装的所有扩展应该都在这个路径中，这个路径在配置settings.json时需要用到。 安装完成 3.2 配置Haskell语言学习环境（1）配置ghc-mod、hlint、Code Runner在VSCode中打开 文件（File）- 首项选（Preferences）- 设置（Settings），点击下图红圈的位置，打开settings.json。 设置 settings.json 在settings.json文件中加入以下代码，注意在第8行末尾增加逗号，其中Haskell-linter配置的路径就是上面那个提示的路径。 12345678 /* Haskell ghc-mod配置 */ &quot;haskell.ghcMod.executablePath&quot;: &quot;stack&quot;, /* Haskell-linter配置 */ &quot;haskell.hlint.executablePath&quot;: &quot;C:\\\\Users\\\\hp\\\\AppData\\\\Roaming\\\\local\\\\bin\\\\hlint.exe&quot;, /* code-runner配置 */ &quot;code-runner.executorMap&quot;: { &quot;haskell&quot;: &quot;cd $dir &amp;&amp; stack runhaskell $fileName&quot;}, settings-over （2）配置Haskell由于使用的是Stack，下列配置项要么添加到全局配置文件 $STACK_ROOT\\config.yaml 中，要么添加到项目配置文件 stack.yaml 中： 12ghc-options: '$everything': -haddock # 一个从带注释的Haskell源代码自动生成文档的工具 4. 尝试使用经过以上操作，haskell的环境基本搭建完毕，写一个简单的Hello World来测试是否成功。在VSCode运行.hs文件基本有以下三种方式： 在终端输入stack runhaskell &quot;.hs文件路径&quot;（最稳定）。 点击右上角的小三角运行按钮。 点击最下面蓝色行用红笔圈出的Run File运行文件。 可以看到成功输出了Hello World。 爷终于成功了哈哈哈哈哈 tips:在实际使用的过程中，想引用import System.Random时却发现系统提示没有这个模块，在查找了无数资料后，终于在这个网站中找到了可行的解决方案，可以尝试在终端输入下面的第一行代码，如果无效则尝试第二行代码： 12stack install randomstack ghci --package random 附：一些个人认为比较有用的Haskell入门资料 Haskell - 条件判断 Haskell系列（三）列表","link":"/2022/03/10/Windows10-%E5%92%8C-VSCode-%E4%B8%8AHaskell%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"计算机网络实验 Labexercise1-1 Protocol Layers","text":"前言：本博客包含Windows10下安装wget、Wireshark。 一些有用的链接： Labexercise1-1 Protocol Layers翻译 wireshark练习及答案lab-protocol-layers.docx Wireshark抓包使用指南 山东大学计算机网络实验 一些有用的提示：开始实验进行抓包时，校园网环境下的同学不建议使用一些 [ 上网不涉密涉密不上网 ] 的校园网进行抓包，可能会导致抓不到包捏 :)（找了半天bug，气死我了） 1. 下载安装wget参考资料：wget for windows 下载与安装 点击此链接，选择合适的版本下载.exe文件，然后把下好的.exe文件放在C:/windows/system32目录下即可。 在cmd终端输入wget --version，显示如下，则安装成功: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849C:\\Users\\hp\\Desktop&gt;wget --versionGNU Wget 1.21.2 built on mingw32.+cares +digest +gpgme +https +ipv6 +iri +large-file +metalink -nls+ntlm +opie +psl +ssl/opensslWgetrc: /win32dev/misc/wget/out64/etc/wgetrc (system)Compile: x86_64-w64-mingw32-gcc -DHAVE_CONFIG_H -DSYSTEM_WGETRC=&quot;/win32dev/misc/wget/out64/etc/wgetrc&quot; -DLOCALEDIR=&quot;/win32dev/misc/wget/out64/share/locale&quot; -I. -I../../src -I../lib -I../../lib -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DCARES_STATICLIB -I/win32dev/misc/wget/out64/include -DPCRE2_STATIC -I/win32dev/misc/wget/out64/include -DHAVE_LIBSSL -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DNDEBUG -ggdbLink: x86_64-w64-mingw32-gcc -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DCARES_STATICLIB -I/win32dev/misc/wget/out64/include -DPCRE2_STATIC -I/win32dev/misc/wget/out64/include -DHAVE_LIBSSL -I/win32dev/misc/wget/out64/include -I/win32dev/misc/wget/out64/include -DNDEBUG -ggdb -L/win32dev/misc/wget/out64/lib -L/win32dev/misc/wget/out64/lib -lmetalink -lunistring -liconv -L/win32dev/misc/wget/out64/lib -lcares -L/win32dev/misc/wget/out64/lib -lpcre2-8 -L/win32dev/misc/wget/out64/lib -lssl -lcrypto -L/win32dev/misc/wget/out64/lib -lz -L/win32dev/misc/wget/out64/lib -lpsl -lidn2 -lunistring -liconv -lws2_32 -lole32 -lcrypt32 -lexpat -L/win32dev/misc/wget/out64/lib -lgpgme -lassuan -lgpg-error ftp-opie.o mswindows.o openssl.o http-ntlm.o ../lib/libgnu.a -lws2_32 -lws2_32 -lws2_32 -lws2_32 -lws2_32 -lws2_32 /win32dev/misc/wget/out64/lib/libiconv.a /win32dev/misc/wget/out64/lib/libunistring.a -lws2_32Copyright (C) 2015 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later&lt;http://www.gnu.org/licenses/gpl.html&gt;.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Originally written by Hrvoje Niksic &lt;hniksic@xemacs.org&gt;.Please send bug reports and questions to &lt;bug-wget@gnu.org&gt;. 尝试使用wget时，可以在终端输入wget 网址把目标链接下载到当前目录下，也可以输入wegt -p 指定目录 网址把目标链接下载到指定目录下。 2. 下载安装Wireshark参考资料：win10安装抓包工具wireshark 在Wireshark的官网下载地址中，在Stable Release中选择符合你计算机型号的安装包，我Windows10 64位电脑选择的是 Windows Installer (64-bit)，双击下载的.exe文件进行安装。 如果你仅仅只是为了完成课程实验，在安装的过程当中可以一路无脑next，在选择安装路径时可以更改为你想要的路径。 3.开始实验Step 1-3打开Wireshark，界面如下图所示，选择WLAN，点击捕获-选项。 在捕获选项界面，仅勾选WLAN，取消其他接口的混杂，在下方绿色的部分输入tcp port 80，使用“tcp端口80”筛选器启动捕获。 打开cmd终端，抓包一个网站，这里选择的是https://www.baidu.com/，网页获取完成后，立刻在Wireshark点击左上角的停止（红色正方形），显示如下图。 找到上方Protocol为HTTP，且Info是GET的，点击蓝色部分的Hypertext，可以看到整个窗口的最下方显示415 byte(s)，这是HTTP的实际有效开销。 接下来分别查看以太网（Ethernet）、IP、TCP占用的字节，分别如下为14 types、20 types、20 types。 由此，可以回答实验报告中的第一个 turn in：Step 3: Packet StructureTurn-in: Hand in your packet drawing. Step 4Protocol Overhead指的是协议开销，由于协议本身的报头等内容也需要占用一定的空间，用来标识该种协议、报文内各个字段的含义等信息，这种内容就是协议开销了。下载的包从一个Info中带有SYN，ACK信号的包开始，到下面第一个遇到的HTTP包后面的TCP包为止。 由此，可以回答实验报告中的第二个 turn in：Your estimate of download protocol overhead as defined above. Tell us whether you find this overhead to be significant.协议开销一共有 66+54+469+66=665字节HTTP有效开销一共有415字节，415/665≈62.41%，协议开销占比较小。 Step 5点击中间那一栏的以太网和IP，分别可以从Type和Protocol中找到第五步问题的答案。 由此，可以回答实验报告中的第三个 turn in： Which Ethernet header field is the demultiplexing key that tells it the next higher layer is IP? What value is used in this field to indicate “IP”?以太网报头字段是Type，对应的值是0x0800。 Which IP header field is the demultiplexing key that tells it the next higher layer is TCP? What value is used in this field to indicate “TCP”?IP报头字段是Protocol，对应的值是6。","link":"/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Labexercise1-1-Protocol-Layers/"},{"title":"基于Icarus5.x的主题美化改造","text":"看了下网上的教程，Hexo Icarus主题的美化改造大部分是基于2.x/3.x，用的都是ejs文件，而Icarus在4.x版本之后就用jsx文件进行编写了，网上那些美化的代码也不能完全适用，即使在Icarus官网4.x美化的教程中，也有一部分配置文件和5.x不一致，因此我打算写一个博客来记录下我给Icarus5.0.0美化的过程。 一些有用但不完全有用的资料这些资料大部分基于Icarus4.x主题，有一定的参考价值，但在一些小细节上有一定出入。 Icarus用户指南 Icarus 主题自定义 hexo更换icarus主题和美化 到 ICARUS 中去 —— 记对 Icarus 主题的使用及微调 给博文添加ReadMore在Icarus还是ejs的时代，可以根据这位大佬的教程来编写ejs文件实现自动添加ReamMore的效果，但是在5.0版本中，我只能自己手动在博文里添加ReadMore。在_config.icarus.yml文件中添加以下代码： 123#read more auto_excerpt: enable: true 然后在你的博客md里面你想要的位置手动添加&lt;!--more--&gt;。 添加访客地球小组件 功能：展示页面的总浏览量/页面浏览人来源的的热力图/同时在线人的地址标签 地址：RevolverMaps官网 找到.\\themes\\icarus\\layout\\common\\scripts.jsx，在return部分做出如下修改： 12345678910111213 return &lt;Fragment&gt; &lt;script src={cdn('jquery', '3.3.1', 'dist/jquery.min.js')}&gt;&lt;/script&gt; &lt;script src={cdn('moment', '2.22.2', 'min/moment-with-locales.min.js')}&gt;&lt;/script&gt; {clipboard &amp;&amp; &lt;script src={cdn('clipboard', '2.0.4', 'dist/clipboard.min.js')} defer&gt;&lt;/script&gt;} &lt;script dangerouslySetInnerHTML={{ __html: `moment.locale(&quot;${language}&quot;);` }}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: embeddedConfig }}&gt;&lt;/script&gt; &lt;script src={url_for('/js/column.js')}&gt;&lt;/script&gt; &lt;Plugins site={site} config={config} page={page} helper={helper} head={false} /&gt; &lt;script src={url_for('/js/main.js')} defer&gt;&lt;/script&gt; &lt;script src={url_for('/js/clicklove.js')} defer={true}&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;color=&quot;220,220,220&quot; opacity='0.7' zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;+ &lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; &lt;/Fragment&gt;; 添加的那一行代码为： 1&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 然后在.\\themes\\icarus\\layout\\widget中新建map.jsx文件，把以下代码复制到这个文件中： 12345678910111213const { Component } = require('inferno');const gravatrHelper = require('hexo-util').gravatar;const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');class Profile extends Component { render() { return &lt;Fragment&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; &lt;/Fragment&gt;; }}module.exports = Profile; 最后打开Icarus的全局配置文件_config.icarus.yml，找到widgets栏，添加如下代码： 1234# 地球小组件- type: map position: right 主页是三栏，点开文章变两栏主要参考了这位大佬的教程，具体过程比较坎坷，为了省事你可以把.\\themes\\icarus\\layout\\layout.jsx整体替换为以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const { Component } = require('inferno');const classname = require('hexo-component-inferno/lib/util/classname');const Head = require('./common/head');const Navbar = require('./common/navbar');const Widgets = require('./common/widgets');const Footer = require('./common/footer');const Scripts = require('./common/scripts');const Search = require('./common/search');module.exports = class extends Component { render() { const { site, config, page, helper, body } = this.props; const language = page.lang || page.language || config.language; const columnCount = Widgets.getColumnCount(config.widgets, config, page); if(page.path==='index.html'){ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; } else{ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; } }}; 给文章添加黏性目录和访问量黏性目录在toc.js文件中大概213行处做如下修改： hexo\\node_modules\\hexo-component-inferno\\lib\\view\\widget\\toc.js123456 var css = '#toc .menu-list &gt; li &gt; a.is-active + .menu-list { display: block; }' + '#toc .menu-list &gt; li &gt; a + .menu-list { display: none; }';- return (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card widget&quot;, [(0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card-content&quot;, (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;menu&quot;, [(0, _inferno.createVNode)(1, &quot;h3&quot;, &quot;menu-label&quot;, this.props.title, 0), this.renderToc(toc, showIndex)], 0), 2), collapsed ? (0, _inferno.createVNode)(1, &quot;style&quot;, null, null, 1, {+ return (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card widget is-3-column-toc&quot;, [(0, _inferno.createVNode)(1, &quot;div&quot;, &quot;card-content&quot;, (0, _inferno.createVNode)(1, &quot;div&quot;, &quot;menu&quot;, [(0, _inferno.createVNode)(1, &quot;h3&quot;, &quot;menu-label&quot;, this.props.title, 0), this.renderToc(toc, showIndex)], 0), 2), collapsed ? (0, _inferno.createVNode)(1, &quot;style&quot;, null, null, 1, { &quot;dangerouslySetInnerHTML&quot;: { __html: css } 并在style.styl中增加以下代码： .\\themes\\icarus\\source\\css\\style.styl12345678/* 黏性目录 */.is-1-column-toc /* 如当前列数为1，则目录采用原来的样式 */.is-2-column-toc, .is-3-column-toc /* 如当前列数为2或3，则目录采用粘性布局 */ position: sticky position: -webkit-sticky top: 0 z-index: 1 访问量将主题配置文件_config.icarus.yml的 plugins &gt; busuanzi 设置为 true 即可 给文章添加评论区官方文档Icarus用户指南 - 用户评论插件提供了十多种可以适配Icarus的评论插件，在对比了安全性和易上手度之后，我选择的是Waline评论区插件。 （1）按照Waline官方文档快速上手创建LeanCloud应用和Vercel项目，在Vercel 部署 (服务端)这一步中选择GitHub登录，项目库选择你博客所在的仓库。 （2）对于Waline插件的引入，在.\\themes\\icarus\\layout\\common\\scripts.jsx的return部分添加以下代码： 1&lt;script src=&quot;//cdn.jsdelivr.net/npm/@waline/client&quot;&gt;&lt;/script&gt; （3）将你Vercel项目的”服务器地址“(Server URL)复制到主题配置的对应配置项中。 _config.icarus.yml123456789101112131415161718192021comment: type: waline server_url: https://your-domain.vercel.app lang: zh-CN # 可选填 visitor: false # 可选填 emoji: # 可选填 - 'https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo' dark: auto # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 required_meta: [] # 可选填 login: enable # 可选填 avatar: mp # 可选填 word_limit: 0 # 可选填 page_size: 10 # 可选填 avatar_cdn: 'https://sdn.geekzu.org/avatar/' # 可选填 avatar_force: false # 可选填 highlight: true # 可选填 math_tag_support: false # 可选填 copyright: true # 可选填 locale: # 可选填 placeholder: 'Comment here...' tips： 对于Waline插件的更多了解和样式设计可以参照官方文档客户端介绍。 自定义网站的logo和favicon可以搜索在线制图网站生成你的图标和logo，这里推荐LOGO神器，在这里可以智能生成各种好看的图标和logo，但是生成后需要购买会员来下载文件（不过你可以把生成的图片直接截图再抠图就是了）。 将生成的图片转化为svg格式推荐onlineconvertfree，这个网站可以免费进行图片格式的转换，下载转换后的图片也非常方便。","link":"/2022/03/15/%E5%9F%BA%E4%BA%8EIcarus5-x%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%94%B9%E9%80%A0/"},{"title":"编译原理与设计-Lab2-编译器认知实验","text":"本实验主要的内容为在 Linux 平台上安装和运行工业界常用的编译器 GCC 和LLVM，如果系统中没有安装，则需要首先安装编译器，安装完成后编写简单的测试程序，使用编译器编译，并观察中间输出结果。 一、实验目的和内容 实验目的本实验的目的是了解工业界常用的编译器 GCC 和 LLVM，熟悉编译器的安装和使用过程，观察编译器工作过程中生成的中间文件的格式和内容，了解编译器的优化效果，为编译器的学习和构造奠定基础。 实验内容本实验主要的内容为在 Linux 平台上安装和运行工业界常用的编译器 GCC 和LLVM，如果系统中没有安装，则需要首先安装编译器，安装完成后编写简单的测试程序，使用编译器编译，并观察中间输出结果。 实验环境处理器 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz 1.99 GHz机带 RAM 16.0 GB (15.9 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Ubuntu 20.04.3 LTS内存 8GB硬盘（SCSI）100GLinux内核 Linux 5.15.2 二、实验的具体过程和步骤 1. 编译器安装12sudo apt-get install llvm sudo apt-get install clang 2. 编写测试程序单个程序1234#include &lt;stdio.h&gt; int main(){ printf(&quot;HelloWorld\\n&quot;); } 多个程序cal.c12345678#include &lt;stdio.h&gt; int add(int a,int b); int main(){ int num1, num2; scanf(&quot;%d %d&quot;,&amp;num1,&amp;num2); int res = add(num1,num2); printf(&quot;%d\\n&quot;, res); } add.c123#include &quot;add.h&quot; int add(int num1, int num2){ return num1+num2;} 3. 运行编译器进行观测GCC查看编译器版本12gcc -v gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04) 使用GCC编译链接单个文件1gcc -o hello hello.c 使用GCC编译多个文件1gcc -o cal cal.c add.c 查看预处理结果1gcc -E hello.c -o hello.i 查看语法分析树1gcc -fdump-tree-all hello.c 使用ls -ltr命令，可以看到执行命令后生成的文件。 查看中间代码生成结果1gcc -fdump-rtl-all hello.c 使用ls -ltr命令，可以看到执行命令后生成的文件。 查看生成的目标代码（汇编代码）1gcc -o hello.asm -S hello.c LLVM查看编译器版本12345clang -v clang version 10.0.0-4ubuntu1 Target: x86_64-pc-linux-gnu Thread model: posix InstalledDir: /usr/bin 使用LLVM编译单个文件1clang -o hello hello.c 使用LLVM编译链接多个文件1clang -o cal cal.c add.c 查看编译流程和阶段1clang -ccc-print-phases hello.c -c 查看词法分析结果1clang hello.c -fsyntax-only -Xclang -dump-tokens 查看词法分析结果21clang hello.c -fsyntax-only -Xclang -dump-raw-tokens 查看语法分析结果1lang -fsyntax-only -Xclang -ast-dump hello.c 查看语义分析结果21clang hello.c -fsyntax-only -Xclang -ast-view 查看编译优化的结果1clang hello.c -S -mllvm -print-after-all 查看生成的目标代码结果1clang hello.c -S 三、运行结果分析 1. GCC运行结果分析gcc编译的大概步骤是：词法分析 –&gt; 语法分析 –&gt; 生成语法树 –&gt; 高级gimple –&gt; 低级gimple –&gt; cfg –&gt; ssa –&gt;RTL –&gt;目标代码(汇编代码)。 预处理结果运行gcc -E hello.c -o hello.i生成的hello.i文件就是hello.ｃ经过预处理后的文件，一个简单的四行程序，在经过预处理后，多出了许多额外的变量和函数等。 语法分析树输入命令后产生的文件较多，其文件命名格式均为filename.c.t.name。 将其中的005.gimple､008.lower､014.printf与源文件进行对比,可以看到: 在005.gimple中,main函数转换为了高端gimple,在这一部分中,程序以函数为单位进行转化,将函数内部的变量以及编译器创建的临时变量都提高到最开始的位置,并将函数的执行语句集中到了一起,其顺序与语法树中所表现的顺序一致｡ 在008.lower中,gimple用lower动作,将高层次的gimple解析成了低层次,此过程主要完成了数据合并､代码合并和返回语句合并｡ 014.printf是低层次gimple转换为cfg的中间代码,cfg的主要作用是在低端gimple的基础上将语句分成几个基本块(basic block),在基本块内,代码是顺序执行的,不存在跳转语句,如果有跳转语句,则放在块的最后,保证跳转只发生在块与块之间,即在gimple中,指令跳转的语句就是基本块的边界｡ cfg转换为ssa则是为每个变量增加一个版本号,用于数据流的优化,其结构和地段fimple相同｡ 中间结果及目标代码使用命令后产生的文件较多，在中间结果中，为了保证同一段代码在不同平台都可以顺利运行，GCC提供了RTL这种中间形式的汇编语言，将所有优化都基于RTL完成，之后再转变为针对不同硬件平台的汇编代码，RTL生成的目标代码也就是汇编代码。 2. LLVM运行结果分析在进行编译时，返回的结果如上图所示，其中： ０：获得源代码ｃ语言文件。 １：预处理阶段，做出相应的处理，包括宏的替换、头文件的导入等。 ２：编译阶段。 ３：通过后端进行汇编前的处理。 ４：汇编链接。 词法分析这一步，源代码被切割成了一个个Token，比如左右括号、字符串等，可以看到词法分析２仅包含头文件的词法分词结果，而词法分析仅包括对源文件的词法分析结果。 语法分析语法分析主要检验程序的语法是否正确，而后将节点抽象为语法树AST。 查看编译优化结果生成中间代码IR，代码生成器会将语法树自顶向下遍历逐步翻译成LLVM IR，此过程中LLVM会进行优化工作，也可以设置优化级别-01，-02，-03等。 生成汇编文件下图为源文件和生成的汇编代码的对比： 四、GCC与LLVM对比分析 1. 汇编文件对比源文件均为c语言的HelloWorld，下图分别为gcc的汇编文件和llvm的汇编文件。 2. 优化编译由于HolleWorld的优化空间不大，此处采用第一个实验中的快排程序QSort.cpp作为源码，选择对规模为10000的逆序数组进行顺序排列，时间复杂度为O(n²)。在两个编译器中分别使用-O0（默认）、-O1、-O2、-O3进行优化编译，每组实验重复五次取消耗时间的平均值作为运行效率，进行对比。 GCC优化编译以下步骤运行五次求平均值，四种优化的耗时分别为：238477.8、68093.2、50332、46271.6。 LLVM优化编译以下步骤运行五次求平均值，四种优化的耗时分别为：174027.8、22891、33568.2、34258.2。 GCC和LLVM优化编译对比从下图中可以看出，LLVM的优化效率明显高于GCC，但是对于快排这样少循环多递归的程序，LLVM中-O2和-O3的优化效率反而不如-O1，但这三者的优化效率都远远高于默认的-O0。 五、实验心得体会 在本次实验中，我新接触到了一种工业界常用的编译器LLVM，在对比之后才发现，LLVM的编译优化效率远高于GCC。通过本次实验，我进一步了解到了编译器编译的原理和过程，为我接下来对编译器的学习奠定了基础。","link":"/2022/03/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab2-%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%A4%E7%9F%A5%E5%AE%9E%E9%AA%8C/"},{"title":"编译原理与设计-Lab1-程序设计语言认知","text":"分别使用 C/C++、Java、Python 和 Haskell 实现快速排序，对采用这几种语言实现的编程效率，程序的规模，程序的运行效率进行对比分析。 一、实验目的和内容 实验目的了解程序设计语言的发展历史，了解不同程序设计语言的各自特点；感受编译执行和解释执行两种不同的执行方式，初步体验语言对编译器设计的影响，为后续编译程序的设计和开发奠定良好的基础。 实验内容分别使用 C/C++、Java、Python 和 Haskell 实现快速排序，对采用这几种语言实现的编程效率，程序的规模，程序的运行效率进行对比分析。 实验环境处理器 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz 1.99 GHz机带 RAM 16.0 GB (15.9 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Windows10 二、实验的具体过程和步骤 实验分为三种情况：1. 普通情况下，对10000个取值区间在1-10000的不重复随机数进行快速排序。 在最坏情况下，对含有1000个元素的降序数组进行升序快速排序。 在最坏情况下，对含有10000个元素的降序数组进行升序快速排序。 1. C++语言编译器版本12C:\\Users\\hp\\Desktop&gt;gcc --version gcc (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;math.h&gt; #include &lt;algorithm&gt; using namespace std; /* N为实验规模，O为实验模式 对不重复的随机数快排的规模为 N = 10000 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 */ #define N 10000 #define O 2 const int MaxN = 1e4 + 10; int a[MaxN], b[MaxN]; //b[i]里面是1-10000不重复的随机数 //求随机数 void ran(){ srand((unsigned)time(NULL)); //初始化随机种子 for(int i = 0; i &lt; 10000; ++i){ a[i] = i + 1; } int index, temp, rest = 10000; for(int i = 0; i &lt; 10000; ++i) { index = rand() % rest; b[i] = a[index]; temp = a[index]; a[index] = a[rest - 1]; a[rest - 1] = temp; rest--; } } //快速排序 void quickSort(int *array, int left, int right) { if(left &gt;= right) return; if(left &lt; right) { int low = left, high = right; int key = array[left]; while(low &lt; high) { while(low &lt; high &amp;&amp; key &lt;= array[high]) high--; array[low] = array[high]; while(low &lt; high &amp;&amp; key &gt;= array[low]) low++; array[high] = array[low]; } array[low] = key; quickSort(array, left, low - 1); quickSort(array, low + 1, right); } } //模式判断 void fill(int arr[]){ //随机数组 if(O == 1){ for (int i = 0; i &lt; N;i++){ arr[i] = b[i]; if(i &lt; 10){ printf(&quot;%d &quot;, arr[i]); //输出前十个随机数 } } } //降序数组 if(O == 2){ for (int i = 0; i &lt; N; ++i) { arr[i] = N - i; } } } int main(){ int arr[N+10]; ran(); fill(arr); int start = clock(); int end = 0; int time = 0; quickSort(arr , 0 , N-1); end = clock(); time = end - start; if(O == 1) printf(&quot;N = 10000, the time of random array is : %d ms\\n&quot;,time); if(O == 2 &amp;&amp; N == 10000) printf(&quot;N = 10000, the time of descending array is : %d ms\\n&quot;,time); if(O == 2 &amp;&amp; N == 1000) printf(&quot;N = 1000, the time of descending array is : %d ms\\n&quot;,time); } 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次12C:\\Users\\hp\\Desktop&gt;gcc -o QSort QSort.cpp C:\\Users\\hp\\Desktop&gt;QSort.exe 2. Java编译器版本123456C:\\Users\\hp\\Desktop&gt;javac --version javac 16 C:\\Users\\hp\\Desktop&gt;java --version java 16 2021-03-16 Java(TM) SE Runtime Environment (build 16+36-2231) Java HotSpot(TM) 64-Bit Server VM (build 16+36-2231, mixed mode, sharing) 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList; public class QSort { /** * N为实验规模，O为实验模式 * 对不重复的随机数快排的规模为 N = 10000 * 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 * O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 */ static int O = 2; static int N = 1000; //模式判断 public static void fill(int[] arr){ ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); int num1 = 10000; for(int i = 1; i &lt; num1 + 1; i++){ list1.add(i); } if (O == 1) { for(int i = 0; i &lt; num1; i++){ //把list1中的数随机存入arr int val = (int)(Math.random()*list1.size()); Object obj = list1.get(val); arr[i] = list1.get(val); list1.remove(obj); //输出前十个随机数 if(i &lt; 10){ if(i == 0) System.out.print(&quot;[&quot;); if(i &lt; 9) System.out.print(arr[i] + &quot; &quot;); if(i == 9) System.out.print(arr[i] + &quot;] &quot;); } } } if(O == 2){ for (int i = 0; i &lt; N; i++) { arr[i] = N - i; } } } //快速排序 public static void quickSort(int []array, int left, int right) { if(left &gt;= right) return; if(left &lt; right) { int low = left, high = right; int key = array[left]; while(low &lt; high) { while(low &lt; high &amp;&amp; key &lt;= array[high]) high--; array[low] = array[high]; while(low &lt; high &amp;&amp; key &gt;= array[low]) low++; array[high] = array[low]; } array[low] = key; quickSort(array, left, low - 1); quickSort(array, low + 1, right); } } public static void main(String[] args){ int[] arr = new int[N]; fill(arr); long start = System.nanoTime(); quickSort(arr,0 , N-1); long end = System.nanoTime(); long time = (end - start) / 1000000; if(O == 1){ System.out.println(&quot;N = 10000, the time of random array is : &quot; + time + &quot; ms&quot;); } if(O == 2){ System.out.println(&quot;N = &quot; + N + &quot;, the time of descending array is : &quot; + time + &quot; ms&quot;); } } } 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次12C:\\Users\\hp\\Desktop&gt;javac QSort.java C:\\Users\\hp\\Desktop&gt;java QSort 3. Python编译器版本12C:\\Users\\hp\\Desktop&gt;python --version Python 3.7.4 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import time import sys import random sys.setrecursionlimit(100000) ''''' N为实验规模，O为实验模式 对不重复的随机数快排的规模为 N = 10000 在对降序数组进行升序排列的最坏情况下，程序最大规模为 N = 10000，最小规模为 N = 1000 O = 1是对不重复的随机数进行排列，O = 2是对降序数组进行升序排列 ''' N = 10000 O = 2 def partition(arr, low, high): i = (low - 1) # 最小元素索引 pivot = arr[high] for j in range(low, high): # 当前元素小于或等于 pivot if arr[j] &lt;= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort(array, left, right): while left &lt; right: mid = partition(array, left, right) if mid - left &lt; right - mid: quicksort(array, left, mid - 1) left = mid + 1 else: quicksort(array, mid+1, right) right = mid - 1 def main(): arr = [0] * 10010 if O == 1: # 生成10000个不重复随机数 arr = random.sample(range(1, 10005), 10000) print(arr[:10]) # 输出前十个随机数 quicksort(arr, 0, N - 1) # print(arr[:10]) # 输出排序后的前十个数 if O == 2: # 降序数组 for i in range(0, N): arr[i] = N - i # print(arr[:10]) # 测试排序是否成功 quicksort(arr, 0, N - 1) # print(arr[:10]) start = time.time() main() end = time.time() cost_time = (end - start) * 1000 if O == 1: print(&quot;Python: N = 10000, the time of random array is : %f ms&quot; % cost_time) if O == 2 and N == 10000: print(&quot;Python: N = 10000, the time of descending array is : %f ms&quot; % cost_time) if O == 2 and N == 1000: print(&quot;Python: N = 1000, the time of descending array is : %f ms&quot; % cost_time) 每更换一次实验情况，都在终端运行8次1C:\\Users\\hp\\Desktop&gt;python QSort.py 4. Haskell编译器版本123456C:\\Users\\hp&gt;stack --version Version 2.7.3, Git revision 7927a3aec32e2b2e5e4fb5be76d0d50eddcc197f x86_64 hpack-0.34.4 C:\\Users\\hp&gt;stack exec -- ghc --version The Glorious Glasgow Haskell Compilation System, version 8.10.7 C:\\Users\\hp&gt;stack exec -- ghci GHCi, version 8.10.7: https://www.haskell.org/ghc/ :? for help 源代码123456789101112131415161718192021222324252627282930313233343536import Data.List import System.CPUTime import Text.Printf import System.Random quickSort :: (Ord a)=&gt;[a]-&gt;[a] quickSort [] =[] quickSort (x:xs)= let smaller=[a|a&lt;-xs,a&lt;=x] bigger=[a|a&lt;-xs,a&gt;x] in quickSort smaller ++[x]++quickSort bigger main = do g &lt;- newStdGen let list1 = take 10000 . nub $ (randomRs (1,10000) g :: [Int]) let list2 = [10000,9999..1] let list3 = [1000,999..1] let list = take 10 list1 let o = 1 -- o == 1是对随机数排序, o == 2是对降序数组进行升序排序 start &lt;- getCPUTime let qlist = quickSort list3 --对不重复10000个随机数进行排序是list1, 对规模为10000/1000的降序数组进行升序排序分别是list2和list3 end &lt;- getCPUTime let len = maximum qlist if o == 1 then print list --输出前十个随机数 else printf &quot;&quot; let ok = take 10 qlist printf &quot;The first ten arranged numbers are: &quot; print ok --输出排序后结果的前十位, 防止快排程序被优化掉 end2 &lt;- getCPUTime let diff = fromIntegral (end - start) / (10^9) if o == 1 then printf &quot;N = 10000, the time of random array without output is : %0.3f ms\\n&quot; (diff :: Double) else printf &quot;N = %d, the time of descending array without output is : %0.3f ms\\n&quot; (len::Int) (diff :: Double) let diff2 = fromIntegral (end2 - start) / (10^9) printf &quot;the time of outputing the resule of QSort is : %0.3f ms\\n&quot; (diff2 :: Double) 每更换一次实验情况，都重新生成一次可执行文件，并在终端运行8次1C:\\Users\\hp&gt; stack runhaskell &quot;c:\\Users\\hp\\Desktop\\QSort.hs&quot; 三、运行效果截图 1. 普通情况对10000个取值区间在1-10000的不重复随机数进行快速排序，对于随机排列的数组，输出前10个数以确定其随机性，运行8次取平均值。 C++语言快速排序平均运行时间：2.000ms Java快速排序平均运行时间：2.875ms Python快速排序平均运行时间：116.261ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：7722.656ms 2. 最坏情况小规模对含有1000个元素的降序数组[1000,999,998,…,2,1]进行升序快速排序。 C++语言快速排序平均运行时间：2.000ms Java快速排序平均运行时间：4.875ms Python快速排序平均运行时间：123.921ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：394.531ms 3. 最坏情况大规模对含有10000个元素的降序数组[10000,9999,9998,…,2,1]进行升序快速排序。 C++语言快速排序平均运行时间：237.500ms Java快速排序平均运行时间：111.500ms Python快速排序平均运行时间：13294.012ms Haskell由于Haskell是一门惰性语言，表达式在其值被需要时才会计算，如果不输出排序后的结果，快排语句会被优化掉而导致耗时一直为0，因此输出排序后的前十个元素、快排语句运行时间和输出快排结果的运行时间；本报告以输出快排结果的时间作为函数运行时间。快速排序平均运行时间：0.000ms输出快排结果平均运行时间：41859.375ms 四、语言易用性和程序规模对比分析 1. 语言易用性语言的学习难度：Python &lt;= Java &lt;= C &lt;&lt; Haskell 。C语言： 编程入门语言，在写程序的时候，会更加习惯c的写法和各种基础操作，但同时c的链表指针和内存管理也具有一定的复杂性。Java： Java的语法和c有一定的相似之处，有c和面向对象作为基础，Java很好理解，而且Java一些函数的功能也非常强大，有自动内存管理，和c比较具有一定的简洁性。Python： Python入门简单易懂，如果有c的基础，Python很快就能被掌握，Python的语法更加简明清晰，程序主体更简洁，学习难度较低。Haskell： 由于大多程序员都是以c这种命令式语言作为基础的，Haskell这种纯函数式语言会让人感觉一时难以理解，它的概念、语法和我们以往接触到的程序都是截然不同的，需要用和我们习惯不同的方式去学习应用。 语言的编程效率：Haskell &lt;= C &lt;= Java &lt;&lt; Python 。C语言： 大多数程序员习惯的基础语言，但和Java/Python相比缺少一定的框架，更适合开发小型项目。在特定情况下，C更容易使开发者最大程度的提示程序运行效率。Java： 大多数大型项目都是基于Java 的相关框架开发的，对于大型项目Java的效率显然更高，而且也会减少各种bug发生的可能性。Python： Python的编程效率是最高的，因为他的语法最简单直白，在人工智能和神经网络领域，使用Python可以更好的提高效率、减少代码规模。而且Python强大的功能也可以让它只用一行代码就完成一个复杂的功能。Haskell： Haskell很少应用于工程，加上对纯函数语言和函数思维的不熟悉，导致Haskell的门槛较高，相应编程效率也会降低，但是在学界尤其是数学领域，其在数学逻辑证明上有独到的优势。总结： 语言的编程效率主要取决于你所要实现的项目，在不同的项目上选用合适的语言工具是提高效率的关键。在本次的快排项目中，C、Java、Python并没有太大的差别，Haskell编程效率最慢也仅仅是因为本人对这种语言的不熟悉导致的，在纯数学逻辑的计算中，Haskell的编程效率反而可能会是最高的。 2. 程序规模Haskell &lt;&lt; Python &lt; Java &lt; C程序的总体规模依次递减，QSort函数部分的代码规模Python、Java、C相差不大，Haskell不管是代码总体规模还是QSort函数部分代码规模都远小于另外三种。 五、程序运行性能对比分析（保留到小数点后三位） 普通情况和小规模的最坏数据中，效率上C语言最快，其次是Java；对于解释型语言，Python较快，Haskell效率最低。但是当数据规模较大时，Java的效率会高于c语言。 六、实验心得体会 本次实验我选择了快速排序这一题目，主要的难点有两个：一是在写Python代码时，由于语言本身和系统的限制，即时用到了“sys.setrecursionlimit(100000)”，但是在运行大规模最坏数据时，程序递归到5584次左右依然会停止，因此修改了快速排序的语法结构，进行了尾递归优化，以缩减堆栈。此外就是初学Haskell语言的困难，面对一种全新的纯函数式语言，最开始是茫然的，但是在查阅了无数资料后，我也发现了这种语言独有的魅力，也更新了自身的思维方式。","link":"/2022/03/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab1-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%AE%A4%E7%9F%A5/"},{"title":"功能性网站分享","text":"本文记录我在做项目时发现的一些实用的功能性网站，以便在打工搬砖的过程中提高效率，本文持续更新…… 图表类 在线制图线上快速绘制流程图、ER图等各种图。 图表秀线上绘制更优雅的图表，例如条形图、饼状图等。 Font Awesome、阿里图标库搜罗了一些现成的icon。 程序类 CodeInWord在Word中优雅的展示代码 | 代码高亮 | 格式化代码。 Markdown 官方教程一些Markdown的速查表、基本语法和扩展语法。 SM.MS快速给本地图片生成URL等，普通用户有免费的5GB空间储存转换的图片，可以购买会员升级空间（100G 59USD，约人民币375元，永久有效）。但是个人觉得免费的5GB够用了，平时的项目截图一张图片平均100KB，能存5000多张呢。不过在实操中发现，一篇文章如果使用较多的图片url，加载速度会很缓慢，如果在md文档中使用本地的相对路径插入图片，在博客上打开文章会很快。","link":"/2022/03/16/%E5%8A%9F%E8%83%BD%E6%80%A7%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/"},{"title":"软件工程-个人项目-数独游戏","text":"本次项目分为三个阶段 第1阶段：生成终局 第2阶段：求解数独 第3阶段：用户界面 项目详细代码和说明可以在我的GitHub项目仓库查看，欢迎关注我的GitHub呀 ヽ(✿ﾟ▽ﾟ)ノ PSP表格 PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟） Planning 计划 120 90 · Estimate · 估计这个任务需要多少时间 3600 4160 Development 开发 1800 2400 · Analysis · 需求分析 (包括学习新技术) 180 180 · 需求分析 (包括学习新技术) · 生成设计文档 60 30 · Design Review · 设计复审 (和同事审核设计文档) 60 40 · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 30 30 · Design · 具体设计 180 200 · Coding · 具体编码 720 750 · Code Review · 代码复审 90 60 · Test · 测试（自我测试，修改代码，提交修改） 120 120 Reporting 报告 120 180 · Test Report · 测试报告 40 30 · Size Measurement · 计算工作量 20 20 · Postmortem &amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 60 30 合计 3600 4160 第一阶段：生成终局一、解题思路首先上网查阅资料，了解数独游戏规则：标准数独是由一个给与了提示数字的9x9网格组成，每行、列、宫各自都要填上1-9的数字，要做到每行、列、宫里的数字都不重复。 宫是由3×3的小格子组成的。 在刚拿到题目后，我对于数独终局的生成思路还处于一种比较模糊的状态，初步的想法是先随机生成第一行1-9九个数字，在生成第二行时，每一个数字都与第一行对应列的数字相比较，不能与之重复，以此类推。但是在初步估计时间复杂度后发现，这种方法并不理想，于是上网查阅有关数独终局的资料来寻找数独的规律，试图降低时间复杂度。 经查阅资料可知，对于一个数独终局，第一行固定，从第二行开始，每行依次由第一行左移3、6、1、4、7、2、5、8位生成，则可以生成合格的一个数独终局。 我的学号尾号是9，第一个数字固定为 (0+9) % 9 + 1 = 1，所以通过对第一行进行全排列的方式就可以产生8！= 40320种终局。 此外，对于任意一个数独，第1-3行（列）、4-6行（列）、6-9行（列）中，任意两行（列）交换后数独仍然成立，在保证最左上角数字不变的前提下，可以交换4-6中任意两行，7-9中任意两行。 中间三行的顺序可以为：456、465、564、546、654、645最后三行的顺序可以为：789、798、879、897、987、978 共有8!×3!×3! = 1451520中终局，大于要求的1000000。 二、求解数独程序流程图 三、求解数独程序函数设计12345void swap(int&amp; a, int&amp; b); //交换两个数void create(int n); //生成n个数独终局并写入文件bool permutation(int* p); //排列组合第一行void flag(int f1, int f2); //中间和末尾三行的变换void output(int sudo[9][9], FILE* fp); //把生成的数独写入文件输出 其中主要函数 bool permutation() 代码设计如下： · bool permutation(int* p)该部分代码用于对第一行后八个数字进行全排列。 1234567891011121314151617181920bool permutation(int* p) { //从后往前找，发现后面的数大于前面的数，则停在后一个数 //若没有以上情况，则证明 8！种排列已排完 int i = 7; while (i &gt; 0 &amp;&amp; p[i] &lt; p[i - 1]) i--; if (i == 0) return false; //从后查到i，查到大于p[i - 1]的最小的数，记入k int k = i; for (int j = 7; j &gt;= i; j--) { if (p[j] &gt; p[i - 1] &amp;&amp; p[j] &lt; p[k]) k = j; } swap(p[k], p[i - 1]); //倒置p[last]到p[i] for (int j = 7, k = i; j &gt; k; j--, k++) { swap(p[j], p[k]); } return true;} 第二阶段：求解数独一、解题思路在刚拿到题目后，我最开始想到的是暴力求解，但是题目的范围是1-1000000道，暴力求解时间复杂度过高，在查找资料后采用深搜和剪枝的方法。 数独的求解主要参照了资料数独求解方法，对于空白格子，按照1-9的顺序尝试填入数字，看这个数字在所在行/列/九宫格中是否和其他格子重复，排除不符合要求的数字。如果最终发现1-9每一个数字都不符合要求，则可能是上一个格子填入错误，需要返回上一个空格尝试下一个数字。 二、求解数独程序流程图 三、求解数独程序函数设计1234void solve(const char* txt); //依次读取每个数独并求解void resolve(int row, int col); //求解数独的dfsbool isValid(int row, int col); //判断行、列、九宫格是否有重复void s_output(); //把求解的数独写入文件输出 其中主要函数 resolve() 和 isValid() 代码设计如下： · isValid(int row, int col)该部分代码主要用于深搜的剪枝，判断填入空格的数字是否合法：把数字填入空格时，该数字不能与所在行、列、九宫格重复，如果重复，则返回false，如果没有重复，则返回true。 1234567891011121314151617bool isValid(int row, int col) { int num = s_sudo[row][col]; for (int i = 0; i &lt; 9; i++) { //这一列有重复的 if (s_sudo[i][col] == num &amp;&amp; i != row)return false; } for (int j = 0; j &lt; 9; j++) { //这一行有重复的 if (s_sudo[row][j] == num &amp;&amp; j != col)return false; } int x = (row / 3) * 3; int y = (col / 3) * 3; for (int i = x; i &lt; x + 3; i++) { //所在九宫格有重复的 for (int j = y; j &lt; y + 3; j++) { if (s_sudo[i][j] == num &amp;&amp; i != row &amp;&amp; j != col)return false; } } return true;} · resolve(int row, int col)数独的求解部分采用深度优先搜索，为了减少搜索时间，使用 isValid() 剪枝，如果填入的数字不合法，则尝试下一个数字，直到找到合适的数字为止；如果不存在合法数字，则返回上一个空，重新填写。 在进行了性能分析报告后，发现此函数占用时间较多，为了进一步优化程序减少时间，还应该尽可能减少上一个空格填错数字的可能性，因此可以从空格最少的一行开始填写。以下是深搜函数的流程图和代码： 1234567891011121314151617181920212223242526272829303132333435363738394041void resolve(int row, int col) { if (isOK == 1)return; blank[row]--; for (int i = 1; i &lt; 10; i++) { s_sudo[row][col] = i; if (isValid(row, col)) { //这一行还有空格 if (blank[row] &gt; 0) { int j; for (j = 0; j &lt; 9; j++) { if (s_sudo[row][j] == 0)break; } resolve(row, j); } //这一行没有空格了 else { int next_row = -1; for (int k = 0; k &lt; 9; k++) { //找到下一个空白最少的一行 if (blank[k] == 0)continue; if (next_row == -1)next_row = k; if (blank[k] &lt; blank[next_row])next_row = k; } if (next_row == -1) { //数独没有空行了 isOK = 1; return; } int j; for (j = 0; j &lt; 9; j++) { if (s_sudo[next_row][j] == 0)break; } resolve(next_row, j); } if (isOK == 1)return; } } //9个数字都尝试完，没有符合要求的，证明上一个数字填错了，返回 s_sudo[row][col] = 0; blank[row]++; return;} 第三阶段：用户界面一、解题思路在Visual Studio 2019中新建 Windows 窗体应用项目，为游戏设计大体功能：新游戏、重新开始、提示、提交、退出。 （1）新游戏用户点击“新游戏”，数独棋盘随机生成新的数独题目，计时从0开始。用户可以在棋盘上的空格里填写数字1-9，或者按退格删除填写的数字。开始游戏后，用户可以选择重新开始、提示、提交、退出。用户每一次点击“新游戏”，棋盘上都会生成新的题目。 （2）重新开始用户点击“重新开始”，现在棋盘上已经填写的数字会被清空，用户可以重新开始计算这局数独，计时不会清零。 （3）提示用户点击“提示”，从棋盘第一个空开始依次扫描，当发现有填写错误的空时，错误的地方标红作为提示；如果在扫描出错误之前发现有空白的空，则显示此空的正确答案作为提示。每使用一次提示，总计时会增加五秒作为惩罚计时。 （4）提交用户点击“提示”，系统检测整个棋盘，如果用户还有空格未填写，提示数独未完成；如果填写完成但是与答案不符，提示数独填写有错误；如果用户填写与答案一致，则恭喜用户完成数独，同时停止计时，显示用户解出数独的时间。 （5）退出用户可以在任意时刻点击“退出”，点击后窗口会关闭。 二、用户界面顺序图 三、用户界面程序设计用户界面程序总共包含两个类，两个类中的函数分别如下： 12public partial class Form1 : Form //窗口界面public class sudoku //数独生成和求解 12345678910public Form1()private void Form1_Load(object sender, EventArgs e) //窗口private void Txt_KeyPress(object sender, KeyPressEventArgs e) //让用户只能输入数字1-9或退格键private void Init() //初始化数独棋盘private void button1_Click(object sender, EventArgs e) //点击开始新游戏private void Quit_Click(object sender, EventArgs e) //退出private void Submit_Click(object sender, EventArgs e) //点击提交并判断题目完成度private void Tips_Click(object sender, EventArgs e) //提示private void Restart_Click(object sender, EventArgs e) //重新开始本局private void timer1_Tick(object sender, EventArgs e) //计时器 12345public sudoku()public void flag(int f1, int f2) //中间和末尾三行的变换void output(int flag_mid, int flag_end) //把生成的数独根据变换写入question[,]，answer[,]public void b_blank() //给数独题目question[,]挖空public void create(int[] first) //生成初始数独终局并写入question[,]，answer[,] 关键功能代码详情如下： （1）生成数独题目和新游戏为了使题目具有随机性，且题库数量大于1000000，对于第一行的生成采用随机数的方法，随机生成1-9不重复的九个数，以此代替按顺序对第一行排列组合，关键代码如下： 1234567891011121314151617//生成数独第一行1-9随机数，每个数字各不重复 Random r = new Random(); for (int i = 0; i &lt; array.Length; i++) { array[i] = r.Next(1, 10); if (i &gt; 0) { for (int j = 0; j &lt; i; j++) { if (array[i] == array[j]) { i--; break; } } } } 在确定第一行之后，按照第一阶段生成数独终局的方法，通过对第一行进行不同位次的左移，生成初始数独终局。 为了保证变换的充足性，在生成数独终局的基础上，对于确定行交换的变量flag_mid、flag_end，采取生成1-6随机数的方式，来随机决定生成的数独终局是否进行4-6、7-9行的交换，代码如下： 12345678910111213//第j行为第一行左移shift[j]，变换出完整的数独 for (int j = 1; j &lt; 9; j++) { for (int k = 0; k &lt; 9; k++) { sudo[j, k] = sudo[0, ((k + shift[j - 1]) % 9)]; } } Random rand = new Random(); flag_mid = rand.Next(1, 7); flag_end = rand.Next(1, 7); output(flag_mid, flag_end); 确认最终的数独题目后，把数独终局存入sudoku类中的question[,]，answer[,]数组，answer[,]储存完整的数独终局作为答案，question[,]随机进行挖空，生成带空的数独题目，并且保证每个3×3的小九宫格都至少含有两个空，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940public void b_blank() { Random rdm = new Random(); int blank = rdm.Next(30, 61); //生成30 - 60 个空 //9个3X3，每个3X3的小棋盘中挖空不少于2个。 for (int i = 0; i &lt; 9; i++) { for (int j = 0; j &lt; 2; j++) { int position = rdm.Next(9); //选择3X3里空的位置 int x = i / 3 * 3 + position / 3; int y = i % 3 * 3 + position % 3; //如果这个位置没被挖空，则挖空，反之，再随机一个数 if (question[x, y] != 0) { question[x, y] = 0; blank--; } else { j--; continue; } } } //空还有剩余 while (blank &gt; 0) { int i = rdm.Next(9); int j = rdm.Next(9); if (question[i, j] != 0) //没有被挖空 { question[i, j] = 0; blank--; } } } 确认题目后，将数独题目传入新游戏的textbox[,]数组中，没有挖空的地方设置为只读模式，且底色设置为浅灰色，计时开始。代码和最终效果如下： 1234567891011121314151617181920212223242526272829//生成数独题目并挖空，将题目填入txetbox sudoku.create(array); for(int i = 0; i &lt; 9; i++) { for(int j = 0; j &lt; 9; j++) { textbox[i, j].Text = &quot;&quot;; //每点击一次新游戏，都要归零每一个空格 textbox[i, j].BackColor = Color.White; textbox[i, j].ReadOnly = false; if (sudoku.question[i, j] != 0) { textbox[i, j].Text = sudoku.question[i, j].ToString(); textbox[i, j].ReadOnly = true; textbox[i, j].BackColor = Color.FromArgb(220,220,220); } } } //开始新游戏时，重新开始计时 if (timer1.Enabled == true) { timer1.Enabled = false; label_h.Text = &quot;0&quot;; label_m.Text = &quot;0&quot;; label_s.Text = &quot;0&quot;; } timer1.Enabled = true; （2）重新开始扫描整个棋盘，把非只读模式的格子重新清空。代码和最终效果如下： 12345678910private void Restart_Click(object sender, EventArgs e) { for(int i = 0; i &lt; 9; i++) { for(int j = 0; j &lt; 9; j++) { if (textbox[i, j].ReadOnly == false) textbox[i, j].Text = &quot;&quot;; } } } （3）提示提示会根据用户的大题情况，提示答案或者提示错误，代码和最终效果如下： 1234567891011121314151617181920212223242526272829private void Tips_Click(object sender, EventArgs e) { flag_tips = 1; int e_flag = 0; //e_flag == 1 为提示完毕 for(int i = 0; i &lt; 9; i++) { for(int j = 0; j &lt; 9; j++) { //有空的地方则填上 if(textbox[i, j].Text == &quot;&quot;) { textbox[i, j].Text = sudoku.answer[i, j].ToString(); e_flag = 1; break; } //有错误则提示 if(textbox[i, j].Text != &quot;&quot; &amp;&amp; textbox[i, j].Text != sudoku.answer[i, j].ToString()) { textbox[i, j].BackColor = Color.Red; MessageBox.Show(&quot;标红地方填写错误！&quot;, &quot;提示&quot;); textbox[i, j].BackColor = Color.White; e_flag = 1; break; } } if (e_flag == 1) break; } } （4）提交根据用户不同的答题情况，提交效果分别如下图所示： （5）关于计时器设定每隔一秒触发一次time控件，每触发一次，秒数加一；如果使用了“提示”，秒数加五。把总共耗时的秒数换算成时分秒显示在三个Lable控件上，当点击新游戏时，三个显示时间的Label控件全部归零。代码如下： 123456789101112131415161718public Form1() { InitializeComponent(); Init(); //提交、提示、重新开始按钮不可用 Submit.Enabled = false; Restart.Enabled = false; Tips.Enabled = false; //初始化计时器 label_h.Text = &quot;0&quot;; label_m.Text = &quot;0&quot;; label_s.Text = &quot;0&quot;; timer1.Interval = 1000; label_tips.Text = &quot;tips：&quot; + &quot;\\n\\n&quot; + &quot;每使用一次提示&quot; + &quot;\\n\\n&quot; + &quot;总用时增加五秒&quot;; } 1234567891011121314151617181920212223242526272829303132333435363738private void timer1_Tick(object sender, EventArgs e) { int hour = Int32.Parse(label_h.Text); int min = Int32.Parse(label_m.Text); int sec = Int32.Parse(label_s.Text); sec++; //如果使用了提示，时间额外加5s if (flag_tips == 1) { sec += 5; flag_tips = 0; } //计算小时 if (min == 60) { hour++; label_h.Text = hour.ToString(); label_m.Text = &quot;0&quot;; if (hour == 100) { timer1.Enabled = false; MessageBox.Show(&quot;计时器已达到上限&quot;, &quot;提示&quot;); return; } } //计算分钟 if (sec &gt;= 60) { min++; label_m.Text = min.ToString(); } //计算秒 sec = sec % 60; label_s.Text = sec.ToString(); } 此设定的缺陷：如果用户在一秒内连续点击多次提示，由于time控件每秒只会触发一次，因此只会增加一次惩罚时间（5s）。由于时间原因，此bug暂未修复，会在以后的学习中完善。 总结在这个项目的设计当中，我查阅了很多资料，也参考了很多资料中设计数独、求解数独的思路，增加了独立完成项目代码的经验。同时本次项目是我第一次使用git进行代码提交，第一次尝试用markdown编写博客，第一次对代码进行单元测试和性能分析，第二次利用Windows窗口应用进行GUI的用户界面设计，在收获许多新的方法和技巧时，也初步了解了一个项目开发的经过，增加了自己的项目经验。 同时由于时间和经验的原因，这个项目的功能还不是很完善，例如time控件对惩罚时长的计算存在一些小缺陷，无法判断数独题目是否有唯一解等，在以后的深入学习中，我会进一步提升自己的能力，来完善他们。 出于商业和实用价值，可以考虑在用户使用“提示”功能时，让他们看30s广告来获取收益（手动狗头）","link":"/2022/03/16/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE-%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"编译原理与设计","slug":"编译原理与设计","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Hexo &amp; Icarus","slug":"Hexo-Icarus","link":"/tags/Hexo-Icarus/"},{"name":"打工小妙招","slug":"打工小妙招","link":"/tags/%E6%89%93%E5%B7%A5%E5%B0%8F%E5%A6%99%E6%8B%9B/"},{"name":"软件工程基础","slug":"软件工程基础","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"Guide","slug":"Guide","link":"/categories/Guide/"},{"name":"Experimental report","slug":"Experimental-report","link":"/categories/Experimental-report/"},{"name":"Life &amp; Hello-world","slug":"Life-Hello-world","link":"/categories/Life-Hello-world/"},{"name":"Hello-world","slug":"Life-Hello-world/Hello-world","link":"/categories/Life-Hello-world/Hello-world/"}]}